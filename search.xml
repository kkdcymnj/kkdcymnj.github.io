<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机组成 P2 课下“factorial”题解</title>
    <url>/2025/10/26/P2_off_factorial/</url>
    <content><![CDATA[<h3 id="题面回顾"><a href="#题面回顾" class="headerlink" title="题面回顾"></a>题面回顾</h3><p>运用 MIPS 汇编编写一个计算阶乘的程序。阶乘的结果在 1000 位以内。</p>
<p>程序的执行步数限制在 <strong>200,000</strong> 以内。</p>
<span id="more"></span>
<h3 id="思路建构"><a href="#思路建构" class="headerlink" title="思路建构"></a>思路建构</h3><p>很明显我们需要运用<strong>高精度乘法</strong>完成本题。首先让我们复习一下如何进行两个大数的高精度乘法，下面给出了对应的C语言代码，至于其汇编代码的编写就麻烦大家自行完成了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">char</span> a[<span class="hljs-number">1005</span>],b[<span class="hljs-number">1005</span>];<br><span class="hljs-type">int</span> A[<span class="hljs-number">1005</span>],B[<span class="hljs-number">1005</span>],C[<span class="hljs-number">1005</span>],temp;<br><span class="hljs-type">char</span> out[<span class="hljs-number">1005</span>];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;a;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;b;<br>    <span class="hljs-type">int</span> lena=<span class="hljs-built_in">strlen</span>(a),lenb=<span class="hljs-built_in">strlen</span>(b);<br>    <span class="hljs-type">int</span> len_out=lena+lenb;  <span class="hljs-comment">//a位与b位的数字相乘，结果最多为(a+b)位</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lena;i++)&#123;<br>        A[i]=a[lena-i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lenb;i++)&#123;<br>        B[i]=b[lenb-i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;                       <span class="hljs-comment">//类似于写竖式时，乘数的低位要对齐</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lena;i++)&#123;<br>        temp=<span class="hljs-number">0</span>;             <span class="hljs-comment">//记录进位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;lenb;j++)&#123;<br>            C[i+j]=A[i]*B[j]+temp+C[i+j];<br>            temp=C[i+j]/<span class="hljs-number">10</span>;<br>            C[i+j]%=<span class="hljs-number">10</span>;     <span class="hljs-comment">//想想竖式乘法是怎么计算的</span><br>        &#125;<br>        C[i+lenb]=temp;<br>    &#125;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1004</span>;k&gt;<span class="hljs-number">0</span>;k--)&#123;<br>        <span class="hljs-keyword">if</span>(C[k<span class="hljs-number">-1</span>]!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;                       <span class="hljs-comment">//输出时注意去除前导0</span><br>    <span class="hljs-keyword">for</span>(;k&gt;=<span class="hljs-number">0</span>;k--)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;C[k];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解决了高精度乘法这一问题后，编写计算阶乘的程序似乎就很简单了。我们可以声明三个“数组”A，B 和 C，A 中存放上一次阶乘运算的结果，B 中存放当前乘数，C 中存放本次阶乘的结果。若需要再进行一次阶乘，则将 C 的内容复制到 A，将 A 乘以 B，再得出新的 C 即可。如此一来，我们只需要编写一个三重循环就可以完成任务。</p>
<h3 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h3><p>相信有的读者已经发现了问题：三重循环效率太低，在 200,000 的步数限制下似乎很难完成任务。事实也确实如此。我使用 mars 中的 Instruction Counter 工具得到了计算 40，60 和 100 的阶乘所需要的步数。结果大致如下表所示。</p>
<table>
<thead>
<tr>
<th>阶乘</th>
<th>计算步数</th>
</tr>
</thead>
<tbody><tr>
<td>40!</td>
<td>64,069</td>
</tr>
<tr>
<td>60!</td>
<td>164,903</td>
</tr>
<tr>
<td>100!</td>
<td>538,489</td>
</tr>
</tbody></table>
<p>通过这一份表我们可以看到，我们的代码在计算 60! 时就快要达到最大步数限制了，计算 100! 时就已经严重超出了步数限制——而此时阶乘的结果不过 158 位，远少于 1000 位。目前的这份“三重循环”代码显然需要一定优化。</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>重新审视一下在“三重循环”代码中我们做了什么。在计算 $(n-1)!\times n$ 的循环中，我们做了以下几步：</p>
<ol>
<li><p>一开始 C 中存放了 $(n-1)!$ 的结果，将这一结果复制到 A</p>
</li>
<li><p>将这一次需要的 $n$ 复制到 B</p>
</li>
<li><p>两重循环计算出 $n!$，相应结果存储到 C 中</p>
</li>
</ol>
<p>在以上三个步骤中，1 看起来是比较累赘的，但是某种程度上我们又难以避免。考虑下面的一个场景：</p>
<p>如果我们不将上一次 C 中的内容复制到 A，则 <code>C[i+j]</code> 是这样计算的：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">C<span class="hljs-comment">[i+j]</span> = C<span class="hljs-comment">[i]</span> * B<span class="hljs-comment">[j]</span> + temp + C<span class="hljs-comment">[i+j]</span><br></code></pre></td></tr></table></figure>

<p>如果我们还需要计算 <code>C[(i+j)+k]</code> 中的内容，程序会执行以下语句：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">C<span class="hljs-comment">[(i+j)+k]</span> = C<span class="hljs-comment">[i+j]</span> * B<span class="hljs-comment">[k]</span> + temp + C<span class="hljs-comment">[(i+j)+k]</span><br></code></pre></td></tr></table></figure>

<p>此时计算出的 <code>C[(i+j)+k]</code> 大约是不正确的，因为 <code>C[i+j]</code> 的值在之前已经被改变，并不等于所谓 <code>A[i+j]</code>，也就是说我们没有用原来的乘数乘以新的乘数。</p>
<p>既然如此，有没有什么方法可以尽量避开第 1 步的复制操作呢？以下是我的一些简单思考。</p>
<p><strong>如何“避开”步骤 1 来节省步数？</strong></p>
<p>设想每次的 B 只有 1 位，则我们其实没有必要执行步骤 1 的操作。在这种情况下，循环体中的 <code>j</code> 只可能为 0，新的 C 中第 <code>k</code> 位的结果只另外依赖于 <code>B[0]</code>，<code>A[k]</code> 以及进位 <code>temp</code>。即使我们不将 C 的原有内容复制到 A，即 <code>C[k] = C[k] * B[0] + temp + C[k]</code>，<code>C[k]</code> 的改变也不会影响到 C 中其他位的结果——因为计算其他位的结果根本用不到 <code>C[k]</code>。这样一来，我们的程序也被简化为了<strong>二重循环</strong>，效率上应该有一定提升（因为 <code>j</code> 只能取 0，这一层循环退化掉了）。</p>
<p><strong>如何让 B 只有“1 位”？</strong></p>
<p>我们不一定需要进行 10 进制乘法，可以进行 <strong>1000 进制</strong>的乘法。由于阶乘结果限制在 1000 位以内，B 不会超过 450（450! 的结果为 1001 位）。在 1000 进制的表示下，如果 $B\leq 450$，那么 B 必然只有“1 位”。</p>
<p>进行 1000 进制的乘法也很简单——基本思想和做 10 进制乘法类似，只需作出诸如“<code>%10</code> 改为 <code>%1000</code>”的改变。不过，输出计算结果时需要小心一点，这在下面一点中会提及。</p>
<p><strong>如何输出 1000 进制乘法的结果？</strong></p>
<p>假设阶乘结果在 1000 进制下最高位是第 $m$ 位，我们需要按照第 $m$ 位至第 0 位的顺序依次“拼接”输出。</p>
<p>输出第 $m$ 位（即最高位）：注意不能输出前导 0，也就是说输出 <code>C[m] % 1000</code> 即可。</p>
<p>输出第 $k$ 位（$0\leq k\leq m-1$）：注意需要输出前导 0。可以根据 <code>C[k]</code> 的大小来确定需要补充的前导 0 数量。例如，若 <code>C[k]</code> 是两位数，则需要补充 1 个前导 0。</p>
<h3 id="效果验证"><a href="#效果验证" class="headerlink" title="效果验证"></a>效果验证</h3><p>运用新的代码计算大数阶乘，阶乘数以及对应计算步数如下表所示。</p>
<table>
<thead>
<tr>
<th>阶乘数</th>
<th>计算步数</th>
</tr>
</thead>
<tbody><tr>
<td>40!</td>
<td>5,574</td>
</tr>
<tr>
<td>60!</td>
<td>13,214</td>
</tr>
<tr>
<td>100!</td>
<td>40,157</td>
</tr>
<tr>
<td>200!</td>
<td>185,014</td>
</tr>
<tr>
<td>300!</td>
<td>452,305</td>
</tr>
</tbody></table>
<p>可以看到，如果步数限制为 200,000，这一份代码可以成功计算 200!，效率上相比第一版“三重循环”代码有了显著进步。不过，这离计算 450! 的目标还有比较大的差距。若还想进一步压缩程序执行步数，可以从以下方面考虑：</p>
<ol>
<li><p>“增大”进制，例如计算 10,000 进制乘法。不过进制也不能随意“增大”，毕竟一个字只能存放 <code>int</code> 范围的数据，这一量级是 $10^9$。</p>
</li>
<li><p>减少不必要的寄存器赋值语句，或是适当修改所使用的指令。例如，<code>beq</code> 是基本指令，而 <code>blt</code> 会被展开为 <code>slt</code> 与 <code>bne</code>，实际执行时运行步数就多了。这一点很多时候体现在怎么用 MIPS 书写循环上。</p>
</li>
</ol>
<p>如果只是想通过课程平台的评测，修改后的代码已经足够，数据点还是给得比较松弛的。</p>
<h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><p>下面给出这一题的参考代码。这一份代码只供参考和学习用，请不要随意抄袭。抄袭可能会导致你本次作业记为 0 分，甚至是受到处分。</p>
<p>请批判地学习这份代码。这一份代码只不过是通过了评测，其中体现出的恶劣代码编写习惯请尽量避免（包括但不限于寄存器的随意使用）。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.data</span><br>C:<span class="hljs-meta">.space</span> <span class="hljs-number">5000</span><br><br><span class="hljs-meta">.macro</span> print_int(%<span class="hljs-keyword">sc)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>$<span class="hljs-built_in">a0</span>,%<span class="hljs-keyword">sc</span><br><span class="hljs-keyword"></span>li $<span class="hljs-built_in">v0</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span>.end_macro <br><br><span class="hljs-meta">.macro</span> read_int(%out)<br>li $<span class="hljs-built_in">v0</span>,<span class="hljs-number">5</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>%out,$<span class="hljs-built_in">v0</span><br>.end_macro <br><br><span class="hljs-meta">.macro</span> push(%<span class="hljs-keyword">sc)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">sp</span>,$<span class="hljs-built_in">sp</span>,<span class="hljs-number">4</span><br><span class="hljs-keyword">sw </span>%<span class="hljs-keyword">sc,0($sp)</span><br><span class="hljs-keyword"></span>.end_macro <br><br><span class="hljs-meta">.macro</span> pop(%out)<br><span class="hljs-keyword">lw </span>%out,<span class="hljs-number">0</span>($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">sp</span>,$<span class="hljs-built_in">sp</span>,<span class="hljs-number">4</span><br>.end_macro <br><br><span class="hljs-meta">.macro</span> end<br>li $<span class="hljs-built_in">v0</span>,<span class="hljs-number">10</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span>.end_macro <br><br><span class="hljs-meta">.text</span><br>li $<span class="hljs-built_in">k0</span>,<span class="hljs-number">1</span><br>read_int($<span class="hljs-built_in">s0</span>)	<span class="hljs-comment">#阶乘数</span><br>li $<span class="hljs-built_in">t1</span>,<span class="hljs-number">2</span>	<span class="hljs-comment">#控制阶乘的循环变量</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">k0</span>,C($<span class="hljs-number">0</span>)	<span class="hljs-comment">#结果初始值为1</span><br><span class="hljs-keyword">ble </span>$<span class="hljs-built_in">s0</span>,<span class="hljs-number">1</span>,special	<span class="hljs-comment">#输入0或1，直接特判即可</span><br><br>li $<span class="hljs-built_in">t7</span>,<span class="hljs-number">1</span>	<span class="hljs-comment">#C的位数</span><br><span class="hljs-keyword">jal </span>loop_start<br><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t7</span>,<span class="hljs-number">1</span>	<span class="hljs-comment">#开始结果打印</span><br><span class="hljs-keyword">subi </span>$<span class="hljs-built_in">t7</span>,$<span class="hljs-built_in">t7</span>,<span class="hljs-number">1</span><br>li $<span class="hljs-built_in">v0</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">j </span>print_loop<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">loop_start:</span><br>    push($<span class="hljs-built_in">ra</span>)<br>    <span class="hljs-keyword">j </span>loop_body<br><span class="hljs-symbol">    loop_body:</span><br>    <span class="hljs-keyword">jal </span><span class="hljs-keyword">mult_loop_start</span><br><span class="hljs-keyword"></span>    <span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t1</span>,$<span class="hljs-built_in">t1</span>,<span class="hljs-number">1</span>	<span class="hljs-comment">#B</span><br>    <span class="hljs-keyword">ble </span>$<span class="hljs-built_in">t1</span>,$<span class="hljs-built_in">s0</span>,loop_body<br>    <span class="hljs-keyword">j </span><span class="hljs-keyword">back</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">mult_loop_start:</span><br>    push($<span class="hljs-built_in">ra</span>)<br>    li $<span class="hljs-built_in">t2</span>,<span class="hljs-number">0</span>	<span class="hljs-comment">#高精度乘法的循环变量</span><br>    li $<span class="hljs-built_in">t4</span>,<span class="hljs-number">0</span>	<span class="hljs-comment">#进位记录</span><br>    <span class="hljs-keyword">j </span><span class="hljs-keyword">mult_loop_body</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mult_loop_body:	</span><span class="hljs-comment">#B的值存储在t1中</span><br>    <span class="hljs-keyword">sll </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,<span class="hljs-number">2</span>	<span class="hljs-comment">#获取C这一块内存的数值</span><br>    <span class="hljs-keyword">lw </span>$<span class="hljs-built_in">s1</span>,C($<span class="hljs-built_in">t3</span>)<br><br>    <span class="hljs-keyword">mul </span>$<span class="hljs-built_in">s1</span>,$<span class="hljs-built_in">s1</span>,$<span class="hljs-built_in">t1</span><br>    <span class="hljs-keyword">add </span>$<span class="hljs-built_in">s1</span>,$<span class="hljs-built_in">s1</span>,$<span class="hljs-built_in">t4</span>	<span class="hljs-comment">#C[i]*B+进位t4</span><br>    <span class="hljs-keyword">div </span>$<span class="hljs-built_in">t4</span>,$<span class="hljs-built_in">s1</span>,<span class="hljs-number">1000</span><br>    <span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">s2</span>	<span class="hljs-comment">#余数存入C</span><br>    <span class="hljs-keyword">sw </span>$<span class="hljs-built_in">s2</span>,C($<span class="hljs-built_in">t3</span>)<br><br>    <span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t2</span>,<span class="hljs-number">1</span><br>    <span class="hljs-keyword">blt </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t7</span>,<span class="hljs-keyword">mult_loop_body</span><br><span class="hljs-keyword"></span><br>    <span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t4</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">back	</span><span class="hljs-comment">#如果当前进位不为0，C还需要增加一位</span><br>    <span class="hljs-keyword">sll </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t7</span>,<span class="hljs-number">2</span><br>    <span class="hljs-keyword">sw </span>$<span class="hljs-built_in">t4</span>,C($<span class="hljs-built_in">t3</span>)<br>    <span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t7</span>,$<span class="hljs-built_in">t7</span>,<span class="hljs-number">1</span><br>    <span class="hljs-keyword">j </span><span class="hljs-keyword">back</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">print_loop:</span><br>    <span class="hljs-keyword">sll </span>$<span class="hljs-built_in">t3</span>,$<span class="hljs-built_in">t2</span>,<span class="hljs-number">2</span><br>    <span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t4</span>,C($<span class="hljs-built_in">t3</span>)<br>    <span class="hljs-keyword">div </span>$<span class="hljs-built_in">t4</span>,$<span class="hljs-built_in">t4</span>,<span class="hljs-number">1000</span><br>    <span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">t4</span><br>    <span class="hljs-keyword">jal </span>print_with_front_zero<br>    print_int($<span class="hljs-built_in">t4</span>)<br>    <span class="hljs-keyword">subi </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t2</span>,<span class="hljs-number">1</span><br>    <span class="hljs-keyword">bge </span>$<span class="hljs-built_in">t2</span>,<span class="hljs-number">0</span>,print_loop<br>    end<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">print_with_front_zero:</span><br>    push($<span class="hljs-built_in">ra</span>)<br>    <span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t7</span>,<span class="hljs-keyword">back</span><br><span class="hljs-keyword"></span>    <span class="hljs-keyword">bge </span>$<span class="hljs-built_in">t4</span>,<span class="hljs-number">100</span>,<span class="hljs-keyword">back</span><br><span class="hljs-keyword"></span>    <span class="hljs-keyword">bge </span>$<span class="hljs-built_in">t4</span>,<span class="hljs-number">10</span>,print_ten<br>    <span class="hljs-keyword">j </span>print_digit<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">print_ten:</span><br>    print_int($<span class="hljs-number">0</span>)<br>    print_int($<span class="hljs-built_in">t4</span>)<br>    pop($<span class="hljs-built_in">ra</span>)<br>    <span class="hljs-keyword">subi </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t2</span>,<span class="hljs-number">1</span><br>    <span class="hljs-keyword">bge </span>$<span class="hljs-built_in">t2</span>,<span class="hljs-number">0</span>,print_loop<br>    end<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">print_digit:</span><br>    print_int($<span class="hljs-number">0</span>)<br>    print_int($<span class="hljs-number">0</span>)<br>    print_int($<span class="hljs-built_in">t4</span>)<br>    pop($<span class="hljs-built_in">ra</span>)<br>    <span class="hljs-keyword">subi </span>$<span class="hljs-built_in">t2</span>,$<span class="hljs-built_in">t2</span>,<span class="hljs-number">1</span><br>    <span class="hljs-keyword">bge </span>$<span class="hljs-built_in">t2</span>,<span class="hljs-number">0</span>,print_loop<br>    end<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">special:</span><br>    print_int($<span class="hljs-built_in">k0</span>)<br>    end<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">back:</span><br>    pop($<span class="hljs-built_in">ra</span>)<br>    <span class="hljs-keyword">jr </span>$<span class="hljs-built_in">ra</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机组成课下</category>
      </categories>
      <tags>
        <tag>计算机组成</tag>
        <tag>高精度乘法</tag>
        <tag>MIPS 汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2025 年数据结构与程序设计（信息类）期末考试</title>
    <url>/2025/10/18/final_test/</url>
    <content><![CDATA[<h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a><strong>选择题</strong></h3><ol>
<li><p>若长度为$n$的线性表采用顺序存储结构，在其第$i$个位置插入一个新元素的算法的时间复杂度为________。$(1\leq i\leq n+1)$</p>
<p>A. $O(\lg n)$</p>
<p>B. $O(1)$</p>
<p>C. $O(n)$</p>
<p>D. $O(n^2)$</p>
<span id="more"></span></li>
<li><p>若采用二叉链表的存储结构，在具有$n$个结点的二叉树中，空指针域的个数是________。</p>
<p>A. $2n+1$</p>
<p>B. $n+1$</p>
<p>C. $n-1$</p>
<p>D. 不确定</p>
</li>
<li><p>将数据元素 <code>1, 2, 3, 5, 7, 8, 10, 11, 23, 29, 31, 37, 41, 50</code>依次存放于一个一维数组 <code>[0..13]</code>中，采用折半查找法查找元素23，则被比较过的数组元素的下标依次为________。</p>
<p>A. 6, 12, 10, 8</p>
<p>B. 10, 31, 23</p>
<p>C. 7, 11, 9</p>
<p>D. 6, 10, 8</p>
</li>
<li><p>下列排序方法中，稳定的排序方法是________。</p>
<p>A. 选择排序</p>
<p>B. 谢尔排序</p>
<p>C. 快速排序</p>
<p>D. 插入排序</p>
</li>
<li><p>设有一组记录的关键字为 <code>18, 32, 22, 5, 66, 23, 82, 27, 58, 11, 10, 78</code>，利用散列存储，地址空间范围为 <code>[0..12]</code>，散列函数为$H(key)&#x3D;key\space\mathrm{mod}\space 13$，则散列地址为6的链中有________个结点。</p>
<p>A. 1</p>
<p>B. 2</p>
<p>C. 3</p>
<p>D. 4</p>
</li>
<li><p>若具有$n$个顶点的无向图采用邻接矩阵存储方法，该矩阵一定为一个________。</p>
<p>A. 稠密矩阵</p>
<p>B. 对称矩阵</p>
<p>C. 对角矩阵</p>
<p>D. 稀疏矩阵</p>
</li>
<li><p>一有向带权图如下图所示。若采用Dijkstra算法求源点A到其他各顶点的最短路径，得到的第一条最短路径的目标顶点是C，后续得到的其余各最短路径的目标顶点依次为C,  ________。</p>
<p>A. D, B, F, G, E</p>
<p>B. B, D, E, F, G</p>
<p>C. B, D, G, E, F</p>
<p>D. B, D, E, G, F</p>
</li>
</ol>
<img src="/images/7.png" width=80% height=50% align=center/>

<ol>
<li><p>对如下无向图进行遍历，下列选项中<strong>不可能</strong>是广度优先遍历的是________。</p>
<p>A. a, b, h, e, c, d, f, g</p>
<p>B. e, g, f, a, h, b, c, d</p>
<p>C. c, b, a, e, f, g, h, d</p>
<p>D. g, e, f, a, b, h, c, d</p>
</li>
</ol>
<img src="/images/8.png" width=80% height=50% align=center/>

<ol start="9">
<li><p>若符号 <code>PUSH</code>和 <code>POP</code>分别表示1次进栈与1次出栈操作，则进栈和出栈的操作序列可以表示为仅由 <code>PUSH</code>和 <code>POP</code>组成的序列。对于初态为空的栈，下面给出的操作序列中，________序列<strong>不能</strong>使栈的终态为空。</p>
<p>A. <code>PUSH, PUSH, PUSH, PUSH, POP, POP, POP, POP</code></p>
<p>B. <code>PUSH, POP, PUSH, PUSH, PUSH, POP,PUSH, POP</code></p>
<p>C. <code>PUSH, PUSH, PUSH, POP, PUSH, POP, POP, POP</code></p>
<p>D. <code>PUSH, PUSH, PUSH, POP, POP, PUSH, POP, POP</code></p>
</li>
<li><p>对非空二叉查找树进行________，将一定得到一个有序序列。</p>
<p>A. 前序遍历</p>
<p>B. 中序遍历</p>
<p>C. 后序遍历</p>
<p>D. 层次遍历</p>
</li>
<li><p>循环队列存储在数组 <code>A[0..n]</code>中，<code>front</code>是队头元素下标，则出队时 <code>front</code>操作为________。</p>
<p>A. <code>front=front+1</code></p>
<p>B. <code>front=(front+1)%(n-1)</code></p>
<p>C. <code>front=(front+1)%n</code></p>
<p>D. <code>front=(front+1)%(n+1)</code></p>
</li>
<li><p>若对序列 <code>2, 12, 16, 70, 5, 10</code>按值从小到大排序，前三趟排序结果分别为：</p>
<p>第1趟：<code>2, 12, 16, 70, 5, 10</code></p>
<p>第2趟：<code>2, 5, 16, 70, 12, 10</code></p>
<p>第3趟：<code>2, 5, 10, 70, 12, 16</code></p>
<p>由此可以断定，该排序过程采用的排序方法是________。</p>
<p>A. 快速排序</p>
<p>B. 选择排序</p>
<p>C. 插入排序</p>
<p>D. 冒泡排序</p>
</li>
</ol>
<h3 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a><strong>填空题</strong></h3><ol>
<li>一棵二叉查找树的后序遍历序列为 <code>23, 30, 38, 60, 58, 73, 70, 50</code>，则该二叉查找树的前序遍历序列为________。</li>
<li>若以 <code>{3, 4, 5, 6, 8}</code>作为叶子结点的权值构造哈夫曼树，其带权路径长度为________。</li>
<li>为解决程序执行过程中函数调用与返回的上下文管理问题，通常需要维护一个特殊的数据区，当调用子函数时，系统会将当前函数的返回地址、局部变量及参数等依次存入该数据区，而子函数执行完毕后则按相反顺序从数据区中读取内容恢复调用环境。该数据区的逻辑结构是________。</li>
<li>已知一棵3阶B-树如图所示，若在此B-树上插入关键字 <code>5</code>，则根节点序列为________。</li>
</ol>
<img src="/images/16.png" width=80% height=50% align=center/>

<ol start="5">
<li>已知无向带权图的结构如下图所示。其最小生成树中，各边权重之和为________。</li>
</ol>
<img src="/images/17.png" width=80% height=50% align=center/>

<ol start="6">
<li>一棵完全二叉树，根节点为第1层，第5层叶子结点个数为6，该二叉树最多有________个结点。</li>
<li>用 <code>S</code>表示入栈操作，<code>X</code>表示出栈操作，若元素入栈的顺序为 <code>12345</code>，为了得到 <code>13452</code>的出站顺序，相应的 <code>S</code>和 <code>X</code>的操作串为________。</li>
<li>元素 <code>A, B, C, D, E, F, G</code>依次执行入栈和出栈操作，若所有元素出栈后得到序列 <code>ADFECGB</code>，则栈的容量至少为________。</li>
</ol>
<h3 id="程序题"><a href="#程序题" class="headerlink" title="程序题"></a><strong>程序题</strong></h3><h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a><strong>第一题</strong></h4><p><strong>【问题描述】</strong></p>
<p>一餐馆需要开发一套电子收银系统，提供点菜和统计分析功能。请编程实现电子收银模拟系统：点菜时，需要输入桌台号（小于等于100的正整数表示）、菜品编码、数量（正整数表示）和单价（正整数表示，单位：元），菜品编码由一个大写的英文字母（A表示热菜或凉菜，B表示饮品，C表示主食）和三位0-9的数字组成。每天打烊时，老板希望得到当天的总销售额，并需要按照菜品的销售额由低到高排序输出菜品的销售信息，销售额相同的按照菜品的销售数量由小到大输出（不存在销售数量和销售额都相同的情况）。</p>
<p><strong>【输入形式】</strong></p>
<p>先从控制台输入当天点菜信息条数（大于0且小于100），然后分行输入点菜信息：桌台号、菜品编码、数量和单价之间以一个空格分隔。</p>
<p><strong>【输出形式】</strong></p>
<p>先按照销售额由低到高分行输出各菜品销售信息：菜品编码、该菜品总销售数量和该菜品总销售额之间以一个空格分隔，销售额相同的按照菜品的销售数量由小到大输出；最后输出总销售额。</p>
<p><strong>【样例输入】</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">30</span><br><span class="hljs-number">5</span> A003 <span class="hljs-number">1</span> <span class="hljs-number">38</span><br><span class="hljs-number">5</span> A005 <span class="hljs-number">1</span> <span class="hljs-number">26</span><br><span class="hljs-number">5</span> A012 <span class="hljs-number">1</span> <span class="hljs-number">69</span><br><span class="hljs-number">5</span> B002 <span class="hljs-number">2</span> <span class="hljs-number">10</span><br><span class="hljs-number">5</span> C001 <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">3</span> A006 <span class="hljs-number">1</span> <span class="hljs-number">15</span><br><span class="hljs-number">3</span> A008 <span class="hljs-number">1</span> <span class="hljs-number">33</span><br><span class="hljs-number">3</span> C003 <span class="hljs-number">1</span> <span class="hljs-number">10</span><br><span class="hljs-number">6</span> A012 <span class="hljs-number">1</span> <span class="hljs-number">69</span><br><span class="hljs-number">6</span> A008 <span class="hljs-number">1</span> <span class="hljs-number">33</span><br><span class="hljs-number">6</span> A037 <span class="hljs-number">1</span> <span class="hljs-number">55</span><br><span class="hljs-number">6</span> A020 <span class="hljs-number">1</span> <span class="hljs-number">56</span><br><span class="hljs-number">6</span> A002 <span class="hljs-number">1</span> <span class="hljs-number">99</span><br><span class="hljs-number">6</span> A051 <span class="hljs-number">1</span> <span class="hljs-number">165</span><br><span class="hljs-number">6</span> B005 <span class="hljs-number">12</span> <span class="hljs-number">6</span><br><span class="hljs-number">6</span> C001 <span class="hljs-number">6</span> <span class="hljs-number">1</span><br><span class="hljs-number">6</span> C010 <span class="hljs-number">1</span> <span class="hljs-number">36</span><br><span class="hljs-number">2</span> A008 <span class="hljs-number">1</span> <span class="hljs-number">33</span><br><span class="hljs-number">2</span> A037 <span class="hljs-number">1</span> <span class="hljs-number">55</span><br><span class="hljs-number">2</span> C001 <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">8</span> A008 <span class="hljs-number">1</span> <span class="hljs-number">33</span><br><span class="hljs-number">8</span> A012 <span class="hljs-number">1</span> <span class="hljs-number">69</span><br><span class="hljs-number">8</span> A006 <span class="hljs-number">1</span> <span class="hljs-number">15</span><br><span class="hljs-number">8</span> B005 <span class="hljs-number">2</span> <span class="hljs-number">6</span><br><span class="hljs-number">8</span> C001 <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> A008 <span class="hljs-number">1</span> <span class="hljs-number">33</span><br><span class="hljs-number">1</span> A037 <span class="hljs-number">1</span> <span class="hljs-number">55</span><br><span class="hljs-number">1</span> A003 <span class="hljs-number">1</span> <span class="hljs-number">38</span><br><span class="hljs-number">1</span> B002 <span class="hljs-number">3</span> <span class="hljs-number">10</span><br><span class="hljs-number">1</span> C001 <span class="hljs-number">3</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p><strong>【样例输出】</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">C003 <span class="hljs-number">1</span> <span class="hljs-number">10</span><br>C001 <span class="hljs-number">15</span> <span class="hljs-number">15</span><br>A005 <span class="hljs-number">1</span> <span class="hljs-number">26</span><br>A006 <span class="hljs-number">2</span> <span class="hljs-number">30</span><br>C010 <span class="hljs-number">1</span> <span class="hljs-number">36</span><br>B002 <span class="hljs-number">5</span> <span class="hljs-number">50</span><br>A020 <span class="hljs-number">1</span> <span class="hljs-number">56</span><br>A003 <span class="hljs-number">2</span> <span class="hljs-number">76</span><br>B005 <span class="hljs-number">14</span> <span class="hljs-number">84</span><br>A002 <span class="hljs-number">1</span> <span class="hljs-number">99</span><br>A051 <span class="hljs-number">1</span> <span class="hljs-number">165</span><br>A037 <span class="hljs-number">3</span> <span class="hljs-number">165</span><br>A008 <span class="hljs-number">5</span> <span class="hljs-number">165</span><br>A012 <span class="hljs-number">3</span> <span class="hljs-number">207</span><br><span class="hljs-number">1184</span><br></code></pre></td></tr></table></figure>

<p><strong>【样例说明】</strong></p>
<p>输入了30条点菜信息，汇总统计总销售额为1184元；编码为C003的菜品销售额最低，共10元；编码为A012的菜品销售额最高，销售了3份，共207元；编码为A051、A037和A008的菜品销售额相同，都为165元，这时需要按照销售数量由小到大的顺序输出。</p>
<p><strong>【评分标准】</strong></p>
<p>该题要求实现电子收银模拟系统，提交程序名为 <code>ecr.c</code>。</p>
<ol>
<li>只完成总销售额和菜品销售额统计功能，可得20%分数。</li>
<li>完成统计功能，并实现按照销售额排序可得60%的分数。</li>
<li>完成统计功能，并实现销售额和销售数量排序（如上面样例），可得100%分数。</li>
</ol>
<h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a><strong>第二题</strong></h4><p><strong>【问题描述】</strong></p>
<p>一家新闻社正在跟踪最近的一系列新闻，每条新闻都可以用一个事件表示，其中包含以下信息：事件类型（三种类型，以一个大写字母表示：A表示“突发新闻”、B表示“深度报道”、C表示“评论”）、事件发生时间（以8位数字表示，例如：20240305）和事件标题（不超过100字符的字符串表示，不包含空白符）。所有事件的个数不超过100。</p>
<p>新闻社希望按以下顺序处理这些事件：</p>
<ol>
<li>突发新闻事件（A）应立即处理（优先级最高）。</li>
<li>深度报道事件（B）应排在突发事件之后处理。</li>
<li>评论事件（C）应在所有其他事件处理完成后处理。</li>
<li>相同等级事件按时间倒序整理（即：时间近的先处理），若时间相同，则按照输入的倒序处理（即：先输入的后处理）。</li>
</ol>
<p>主编可以发出两种指令：</p>
<ol>
<li>锁定指令：用大写字母 <code>R</code>表示，后跟需要锁定的新闻事件数量$N$（大于0且小于等于输入的未被锁定的新闻事件数量）；遇到该指令时，需按照上面的处理顺序锁定已经输入的、且未被锁定的$N$个新闻事件。该指令可能没有，也可能有多个。</li>
<li>汇总命令：用大写字母 <code>E</code>表示；遇到该指令时，表示按照上面处理的顺序汇总剩余所有未被锁定的新闻事件，并且代表输入结束。</li>
</ol>
<p>算法提示：</p>
<ol>
<li>可利用三个栈分别存储处理三类新闻事件。</li>
<li>读入事件信息或锁定命令后要注意处理行末的换行符！</li>
</ol>
<p><strong>【输入形式】</strong></p>
<p>按照时间正序从控制台分行输入新闻事件信息，事件类型、事件标题和事件发生时间之间以一个空格分隔；中间可输入多条锁定指令（<code>R</code>与$N$之间以一个空格分隔）；最后输入汇总命令（<code>E</code>）表示输入结束。</p>
<p><strong>【输出形式】</strong></p>
<p>先按照锁定指令输入的先后顺序，分行输出锁定的新闻事件信息（事件类型、事件标题和事件发生时间之间以一个空格分隔）；最后输出遇到汇总命令时，汇总的所有未被锁定的新闻事件信息。</p>
<p><strong>【样例输入】</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">C <span class="hljs-number">20240317</span> Analysis_of_recent_traffic_congestion_situation<br>A <span class="hljs-number">20240317</span> Stock_market_crash<br>B <span class="hljs-number">20240317</span> The_Future_of_Artificial_Intelligence<br>B <span class="hljs-number">20240318</span> The_impact_of_climate_change_on_global_food_supply<br>A <span class="hljs-number">20240319</span> Sudden_earthquake_in_the_Pacific_Plate<br>R <span class="hljs-number">3</span><br>C <span class="hljs-number">20240319</span> Analyze_the_causes_of_extreme_weather_conditions<br>R <span class="hljs-number">1</span><br>A <span class="hljs-number">20240319</span> New_York_City_Suddenly_Falls_lizzard<br>B <span class="hljs-number">20240320</span> Chip_Industry_Chain_Tracking<br>E<br></code></pre></td></tr></table></figure>

<p><strong>【样例输出】</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">A <span class="hljs-number">20240319</span> Sudden_earthquake_in_the_Pacific_Plate<br>A <span class="hljs-number">20240317</span> Stock_market_crash<br>B <span class="hljs-number">20240318</span> The_impact_of_climate_change_on_global_food_supply<br>B <span class="hljs-number">20240317</span> The_Future_of_Artificial_Intelligence<br>A <span class="hljs-number">20240319</span> New_York_City_Suddenly_Falls_lizzard<br>B <span class="hljs-number">20240320</span> Chip_Industry_Chain_Tracking<br>C <span class="hljs-number">20240319</span> Analyze_the_causes_of_extreme_weather_conditions<br>C <span class="hljs-number">20240317</span> Analysis_of_recent_traffic_congestion_situation<br></code></pre></td></tr></table></figure>

<p><strong>【样例说明】</strong></p>
<p>先输入了5条新闻事件，然后遇到锁定3条新闻事件的指令，于是按照规定的处理顺序，锁定了两条突发事件和一条20240318日期的深度报道事件；之后输入1条新闻事件后又遇到锁定1条新闻事件的指令，这次锁定的是20240317日期的深度报道事件；最后输入2条新闻事件后遇到汇总指令，输入结束。输出时：先输出之前锁定的事件，然后按照规定的处理顺序汇总输出所有未被锁定的新闻事件。</p>
<p>注意：由于浏览器显示的差异，从题目中拷贝出的输入样例信息每行后会多出空行，所以测试时请先将输入样例信息拷贝到文本编辑器（例如：记事本）中，删除掉其中的空行后再拷贝到控制台窗口中进行测试！</p>
<p><strong>【评分标准】</strong></p>
<p>该题要求实现新闻的事件的锁定汇总功能，提交程序名为 <code>report.c</code>。</p>
<p>仅实现汇总指令可得30%分数。</p>
<h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a><strong>第三题</strong></h4><p><strong>【问题描述】</strong></p>
<p>目前手机地图均提供根据当前位置查找兴趣点（如餐馆、电影院、品牌专买店、酒店、药店、加油站…）并根据距离远近给出相应路线，如在手机地图（高德、百度…）上查找加油站，将会按距离远近给出加油站及相应线路。编程实现兴趣点查找。</p>
<p><strong>【输入形式】</strong></p>
<p>首先从标准输入读入图顶点的个数$N$（大于0且小于200），图顶点表示地图中的各个位置。</p>
<p>然后从下一行开始分行输入每个顶点的编号（大于等于10）及该顶点包含的兴趣点（用整数1～9来表示不同类型的兴趣点），每行以-1结束，如输入行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">10</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure>

<p>表示编号为10的顶点包含有1、3、5三种兴趣点；</p>
<p>之后输入边的个数$M$（大于0），然后分行输入$M$个以$(u, v, d)$表示的边的信息，其中$u$，$v$为边的2个顶点编号，$d$表示边的长度（以正整数表示），$u$，$v$和$d$之间以一个空格分隔。</p>
<p>最后一行输入要查找的兴趣点编号及当前位置（即：顶点编号），之间以一个空格分隔。</p>
<p><strong>【输出形式】</strong></p>
<p>按照距离由近至远的顺序分行输出找到的包含给定兴趣点的顶点编号、距离及路径（顶点编号、距离及路径之间以一个空格分隔），路径用从当前位置的顶点编号开始，到目标顶点编号所经过的所有顶点编号来表示，路径中的各顶点编号之间以英文减号字符‘-’分隔。</p>
<p>注意：</p>
<ol>
<li>假设没有2个距离完全相同的兴趣点！</li>
<li>如果当前位置就有要查找的兴趣点，则其距离为0（最近），只需输出当前位置顶点编号和距离0，不用输出路径。</li>
</ol>
<p><strong>【样例输入】</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">12</span><br><span class="hljs-number">22</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">-1</span><br><span class="hljs-number">15</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">-1</span><br><span class="hljs-number">56</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">-1</span><br><span class="hljs-number">25</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">-1</span><br><span class="hljs-number">30</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">-1</span><br><span class="hljs-number">18</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">-1</span><br><span class="hljs-number">90</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span> <span class="hljs-number">-1</span><br><span class="hljs-number">67</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">-1</span><br><span class="hljs-number">39</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">9</span> <span class="hljs-number">-1</span><br><span class="hljs-number">89</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">-1</span><br><span class="hljs-number">20</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">-1</span><br><span class="hljs-number">102</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">-1</span><br><span class="hljs-number">14</span><br><span class="hljs-number">56</span> <span class="hljs-number">22</span> <span class="hljs-number">10</span><br><span class="hljs-number">22</span> <span class="hljs-number">15</span> <span class="hljs-number">14</span><br><span class="hljs-number">56</span> <span class="hljs-number">25</span> <span class="hljs-number">6</span><br><span class="hljs-number">15</span> <span class="hljs-number">30</span> <span class="hljs-number">16</span><br><span class="hljs-number">30</span> <span class="hljs-number">90</span> <span class="hljs-number">12</span><br><span class="hljs-number">18</span> <span class="hljs-number">30</span> <span class="hljs-number">20</span><br><span class="hljs-number">18</span> <span class="hljs-number">25</span> <span class="hljs-number">70</span><br><span class="hljs-number">67</span> <span class="hljs-number">18</span> <span class="hljs-number">18</span><br><span class="hljs-number">20</span> <span class="hljs-number">18</span> <span class="hljs-number">20</span><br><span class="hljs-number">67</span> <span class="hljs-number">90</span> <span class="hljs-number">30</span><br><span class="hljs-number">67</span> <span class="hljs-number">39</span> <span class="hljs-number">15</span><br><span class="hljs-number">67</span> <span class="hljs-number">89</span> <span class="hljs-number">14</span><br><span class="hljs-number">89</span> <span class="hljs-number">20</span> <span class="hljs-number">17</span><br><span class="hljs-number">20</span> <span class="hljs-number">102</span> <span class="hljs-number">8</span><br><span class="hljs-number">2</span> <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure>

<p><strong>【样例输出】</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">18</span> <span class="hljs-number">0</span><br><span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">18</span><span class="hljs-number">-20</span><br><span class="hljs-number">102</span> <span class="hljs-number">28</span> <span class="hljs-number">18</span><span class="hljs-number">-20</span><span class="hljs-number">-102</span><br><span class="hljs-number">90</span> <span class="hljs-number">32</span> <span class="hljs-number">18</span><span class="hljs-number">-30</span><span class="hljs-number">-90</span><br><span class="hljs-number">22</span> <span class="hljs-number">50</span> <span class="hljs-number">18</span><span class="hljs-number">-30</span><span class="hljs-number">-15</span><span class="hljs-number">-22</span><br><span class="hljs-number">25</span> <span class="hljs-number">66</span> <span class="hljs-number">18</span><span class="hljs-number">-30</span><span class="hljs-number">-15</span><span class="hljs-number">-22</span><span class="hljs-number">-56</span><span class="hljs-number">-25</span><br></code></pre></td></tr></table></figure>

<p><strong>【样例说明】</strong></p>
<p>该样例输入了12个位置顶点和14条边，形成了如下所示的地图：</p>
<img src="/images/cx3.jpg" width=80% height=50% align=center/>

<p>图中的圆表示顶点，顶点中上方的数字表示顶点编号，下方的数字表示该顶点包含的兴趣点，顶点之间连线上的数字是其边的长度。</p>
<p>要求从当前位置顶点18开始查找包含兴趣点为2的所有位置顶点。</p>
<p>首先，当前位置顶点就包含兴趣点2，其距离最近，所以输出 <code>18 0</code>；</p>
<p>其次距离最近的为与18直接相连的顶点20，距离为20，路径为 <code>18-20</code>。其它4个包含给定兴趣点的顶点类似。</p>
<p><strong>【评分标准】</strong></p>
<p>该题要求从输入的地图中查找所以包含兴趣点的顶点，提交程序名为 <code>search.c</code>。</p>
]]></content>
      <categories>
        <category>试卷</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>期末真题</tag>
        <tag>信息类</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建属于你的 CPU 评测机——单周期 CPU</title>
    <url>/2025/11/23/checker_build/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>在 BUAA CO 课程中，要求使用 Logisim 实现单周期 CPU，使用 Verilog 实现单周期 &#x2F; 流水线 CPU。为了给自己的 CPU 进行较为可靠的测试，我们需要生成具有一定强度的数据，自动化地评测自己的 CPU 是否能够正常工作。</p>
<p>CPU 评测机的架构大致是：数据生成 → 程序运行 → 结果判断。自动评测 Logisim 和 Verilog 实现的 CPU 的主要区别就在后两个环节上，在接下来的文字中我们将详细地介绍。</p>
<span id="more"></span>

<p>本篇博客只涉及单周期 CPU 评测机的搭建工作。搭建好单周期 CPU 的评测机后，搭建流水线 CPU 的评测机也就不是难事了——我们只需要按照要求修改数据生成代码。所以流水线 CPU 评测机的搭建就不另外写一篇博客了，具体的代码和样例请见本人仓库。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为了有一个更为顺畅的阅读和实践体验，请提前准备好 Toby 学长等人开发的符合北航计组课程需求的“魔改版”MARS。<a href="https://github.com/Toby-Shi-cloud/Mars-with-BUAA-CO-extension">下载链接</a></p>
<h3 id="测试样例构建"><a href="#测试样例构建" class="headerlink" title="测试样例构建"></a>测试样例构建</h3><p>这里我们讲解如何自动构造具有<strong>一定强度</strong>且<strong>合法</strong>的测试数据，这也是评测机最为重要的一个环节。</p>
<h4 id="合法性"><a href="#合法性" class="headerlink" title="合法性"></a>合法性</h4><p>这一点在 P4 的评测中尤其重要。P4 时我们会利用“魔改版” MARS 生成样例对应的正确结果，所以我们需要保证程序能够被正确编译，且能被正常执行（主要体现在<strong>不能有死循环</strong>）。</p>
<p>为了解决这个问题，我们一般采用分块构造 + 公共跳转块的办法。我们生成的评测程序大体可以被切分为多个循环块，每个循环块执行完毕后，会跳转到公共跳转块，执行完公共跳转块的程序后，再进入下一个循环块……如此往复，直到到达 <code>end</code> 块，程序执行完毕。在这个过程中，我们可以对 <code>beq</code>、<code>jal</code>、<code>jr</code> 这样的特殊语句进行测试——如果我们没能正确执行这些语句，循环块内的代码很可能不被执行，输出的结果自然也就不正确。</p>
<p>下面以一种“抽象”的方式给出了程序的大致结构，如果看不太明白，仓库中放了一份示例代码，大家可以去参考。可能有的读者注意到了，<code>beq</code>、<code>jal</code>、<code>jr</code> 语句后都添加了 <code>nop</code>，这是为后续流水线 CPU 测试准备的，目前不用太在意这个细节。</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">########<br>    初始化代码<br>########<br><br>jal label_begin<br>nop<br><br>label_begin:<br>    ########<br>        循环体代码<br>    ########<br><br>    ori $<span class="hljs-number">1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br>    add $loop_var,$<span class="hljs-number">1</span>,$loop_var<br><br>    #跳转测试<br>    beq $loop_var, $cycle_num, label_end<br>    nop<br><br>    #跳回测试<br>    jr $ra<br>    nop<br><br>label_end:<br>    ########<br>        循环结束区代码<br>    ########<br><br>    #跳转链接测试<br>    jal common_block<br>    nop<br><br>    #初始化下一个循环块的变量<br>    ori $loop_var_1,$<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>  <br>    #进入下一个循环块<br>    jal label_begin_1<br>    nop<br><br>########<br>    省略多个循环块 <br>########<br><br>label_last_end:<br>    ########<br>        循环结束区代码<br>    ########<br><br>    #程序即将终止<br>    ori $<span class="hljs-number">5</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">5</span> <br>    jal end<br>    nop<br><br>common_block:<br>    ########<br>        公共跳转区代码<br>    ########<br><br>    #跳回测试<br>    jr $ra<br>    nop<br><br>end:<br>    beq $<span class="hljs-number">0</span>,$<span class="hljs-number">5</span>,common_block  <br>    nop<br></code></pre></td></tr></table></figure>

<p>需要注意的是，每一个循环块的执行都会涉及到一个“循环变量”。在循环块内不要操纵“循环变量”，否则很容易产生死循环。</p>
<p>解决了合法性的问题后，我们就可以大胆生成数据，填充循环主体代码了。</p>
<p>注：P3 时我们可以不过多考虑“死循环”问题，因为我们采用两个 Logisim 电路同时对拍的方法，经过一定周期后评测会自动停止。但是到 P4 的评测这个问题就必须纳入考虑，理由已经在上文中说明。</p>
<h4 id="数据强度"><a href="#数据强度" class="headerlink" title="数据强度"></a>数据强度</h4><p>对于数据强度的评价，我们可以从以下几个基本角度评判：</p>
<ol>
<li>是否覆盖了所有指令（这是最基本的要求）</li>
<li>是否能够随机地测试大部分寄存器（这主要体现在 P3 的评测，群里有同学的 GRF 模块漏接线问题没有被课程组的测试测出，尽管这是一个相当明显且严重的问题）</li>
<li>对于内存的读写操作的评判是否真正有效（例如，如果所有内存块内的值都为 0，这时即使你没能正确读出内存内的值，返回的结果也可能为 0，导致无法定位问题）</li>
<li>对于分支 &#x2F; 跳转的评测是否有效、全面（例如 <code>beq</code> 不能从来没有执行过，此种情况下无法查出分支的潜在问题；跳转应该覆盖向前、向后的情况）</li>
<li>是否覆盖了边界值的情况（例如 <code>int</code> 数据范围上下界，0 附近，内存地址上下界等，可以通过手动构造特殊样例来解决）</li>
<li>……</li>
</ol>
<p>总的来说，我们的测试数据应该有较强的随机性，能够覆盖到比较“极端”的情况；应该有较好的有效性，即如果没能正确执行某条指令，会对输出结果产生比较明显的影响。对于数据的生成，我提出一些我的见解，大家可以参考。当然，如果你有比这聪明得多的想法，下面的内容可以忽略。</p>
<ol>
<li>随机初始化，包括寄存器和内存。这里可以对 <code>ori</code>、<code>lui</code>、<code>lw</code>、<code>sw</code> 指令进行测试。如此一来，后面针对寄存器的运算一旦出错，对结果会有比较明显的影响，能够起到“评测”的作用。</li>
<li>对少部分寄存器 &#x2F; 内存地址进行频繁操作。对于寄存器 &#x2F; 内存的频繁操作会频繁地改变其中存储的内容，指令执行不正确可以很快被发现。</li>
<li>涉及到立即数的指令，可以在较大的范围随机生成立即数。例如我通过 <code>randint(immediate_max // 2, immediate)</code> 来生成立即数。当然，也可以设置一定概率，直接生成 <code>immediate_max</code> 作为立即数，其余情况下随机生成。</li>
<li>尽量不要生成无法控制的分支 &#x2F; 跳转指令。极端情况下，PC 可以直接跳到程序末尾，这起不到任何评测的作用。</li>
<li>……</li>
</ol>
<h4 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h4><p>下面来讲解一下数据生成的代码实现，这里会给出一个简单的框架，完整的代码请查看仓库。类似的生成办法可以推广到其他评测机的制作中（例如 OO 课程的），希望大家多加尝试，形成自己的体会。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><br>supported_instr = [...] <span class="hljs-comment">#列表中存储支持的指令类型</span><br>instr_probs = [...] <span class="hljs-comment">#每个指令生成几率，分支、跳转、空指令的几率可以适当小一些</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_loop</span>(<span class="hljs-params">loop_var, cycle_num, body_len, label_num, allowed_instr, generate_prop, instr_list</span>):<br>    <span class="hljs-comment">#循环变量、循环次数、循环体长度、标签、允许在循环体中出现的指令、生成几率、指令列表</span><br><br>    <span class="hljs-comment">#初始化循环变量</span><br>    ...<br>  <br>    <span class="hljs-comment">#添加标签</span><br>    cur_label = <span class="hljs-string">f&quot;label<span class="hljs-subst">&#123;label_num&#125;</span>&quot;</span><br>    instr_list.append(<span class="hljs-string">f&quot;jal <span class="hljs-subst">&#123;cur_label&#125;</span>_begin&quot;</span>) <span class="hljs-comment">#向指令列表中添加指令</span><br>    instr_list.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;cur_label&#125;</span>_begin:&quot;</span>)<br><br>    <span class="hljs-comment">#循环体内容生成</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(body_len):<br><br>        <span class="hljs-comment">#选择需要操作的寄存器</span><br>        choice_range = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(reg_size) <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> &lt;= i &lt;= <span class="hljs-number">25</span> <span class="hljs-keyword">and</span> i != loop_var]<br>        rs = random.choice(choice_range)<br>        rt = random.choice(choice_range)<br>        rd = random.choice(choice_range)<br><br>        cur_instr = random.choices(allowed_instr, generate_prop)[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">match</span> cur_instr:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;add&quot;</span> | <span class="hljs-string">&quot;sub&quot;</span>:<br>                instr_list.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;cur_instr&#125;</span> $<span class="hljs-subst">&#123;rd&#125;</span>,$<span class="hljs-subst">&#123;rs&#125;</span>,$<span class="hljs-subst">&#123;rt&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;lw&quot;</span> | <span class="hljs-string">&quot;sw&quot;</span>:<br>                <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                    address = random.randint(<span class="hljs-number">0</span>, mem_size)<br>                    <span class="hljs-keyword">if</span> address % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>:<br>                        <span class="hljs-keyword">break</span><br>                instr_list.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;cur_instr&#125;</span> $<span class="hljs-subst">&#123;rt&#125;</span>,<span class="hljs-subst">&#123;address&#125;</span>($<span class="hljs-subst">&#123;<span class="hljs-number">0</span>&#125;</span>)&quot;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ori&quot;</span>:<br>                immediate = random.randint(max_immediate // <span class="hljs-number">2</span>, max_immediate)<br>                instr_list.append(<span class="hljs-string">f&quot;ori $<span class="hljs-subst">&#123;rt&#125;</span>,$<span class="hljs-subst">&#123;rs&#125;</span>,<span class="hljs-subst">&#123;immediate&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;nop&quot;</span>:<br>                instr_list.append(<span class="hljs-string">f&quot;nop&quot;</span>)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;lui&quot;</span>:<br>                immediate = random.randint(max_immediate // <span class="hljs-number">2</span>, max_immediate)<br>                instr_list.append(<span class="hljs-string">f&quot;lui $<span class="hljs-subst">&#123;rt&#125;</span>,<span class="hljs-subst">&#123;immediate&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment">#循环尾部代码</span><br>    ...<br><br></code></pre></td></tr></table></figure>

<h4 id="汇编文件及机器码生成"><a href="#汇编文件及机器码生成" class="headerlink" title="汇编文件及机器码生成"></a>汇编文件及机器码生成</h4><p>执行完数据生成的代码后，我们会获得一个 <code>list</code>，我们需要用 <code>\n</code> 拼接 <code>list</code> 中各元素形成一个 <code>str</code>，并导出到 <code>.asm</code> 文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">test_case = <span class="hljs-string">&#x27;\n&#x27;</span>.join(instr_list)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;sample.asm&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(test_case)<br></code></pre></td></tr></table></figure>

<p>接着，我们需要将 <code>.asm</code> 文件在 MARS 中进行编译，生成机器码的 <code>.txt</code> 文件，并进行保存。这一步利用命令行完成会比较方便。注意，如果你想直接使用以下代码，请保证你已经准备好了“魔改版”MARS。官方的 MARS 并没有 <code>CompactLargeText</code> 选项，最多只能支持 1024 条指令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">cmd = <span class="hljs-string">f&quot;java -jar <span class="hljs-subst">&#123;mars_jar&#125;</span> a mc CompactLargeText dump .text HexText <span class="hljs-subst">&#123;output_file&#125;</span> <span class="hljs-subst">&#123;input_file&#125;</span>&quot;</span><br><br><span class="hljs-keyword">try</span>:<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在汇编: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>   result = subprocess.run(cmd, shell=<span class="hljs-literal">True</span>, capture_output=<span class="hljs-literal">True</span>, text=<span class="hljs-literal">True</span>)<br><br>   <span class="hljs-keyword">if</span> result.returncode == <span class="hljs-number">0</span>:<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功生成: <span class="hljs-subst">&#123;output_file&#125;</span>&quot;</span>)<br>   <span class="hljs-keyword">else</span>:<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;汇编失败: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;错误信息: <span class="hljs-subst">&#123;result.stderr&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;错误: <span class="hljs-subst">&#123;filename&#125;</span> - <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="运行-CPU-并实现对拍"><a href="#运行-CPU-并实现对拍" class="headerlink" title="运行 CPU 并实现对拍"></a>运行 CPU 并实现对拍</h3><h4 id="测试模块准备"><a href="#测试模块准备" class="headerlink" title="测试模块准备"></a>测试模块准备</h4><p>这一部分比较简单。Logisim 的测试电路搭建请参考教程，注意不要忘了 <code>halt</code> 信号，否则评测无法终止；Verilog 的 testbench 可以直接用下面这个，注意仿真时间不能设定得太短，否则样例还没执行完仿真就停止了。不要忘记添加 <code>$finish</code> 语句，因为 iVerilog 的仿真是默认一直进行的。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> test;<br><br>	<span class="hljs-comment">// Inputs</span><br>	<span class="hljs-keyword">reg</span> clk;<br>	<span class="hljs-keyword">reg</span> reset;<br><br>	<span class="hljs-comment">// Instantiate the Unit Under Test (UUT)</span><br>	mips uut (<br>		<span class="hljs-variable">.clk</span>(clk), <br>		<span class="hljs-variable">.reset</span>(reset)<br>	);<br><br>	<span class="hljs-keyword">always</span> #<span class="hljs-number">1</span> clk=~clk;<br><br>	<span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>		<span class="hljs-comment">// Initialize Inputs</span><br>		clk = <span class="hljs-number">0</span>;<br>		reset = <span class="hljs-number">1</span>;<br><br>		<span class="hljs-comment">// Wait 100 ns for global reset to finish</span><br>		#<span class="hljs-number">100</span>;<br>		reset=<span class="hljs-number">0</span>;<br>    <br>		<span class="hljs-comment">// Add stimulus here</span><br>		#<span class="hljs-number">100000</span>;<br>		<span class="hljs-built_in">$finish</span>;<br>	<span class="hljs-keyword">end</span><br>  <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>此外，你还需要准备好 <code>logisim-generic-2.7.1.jar</code> 以及 iVerilog，这两项内容均可以在教程中找到资源链接。</p>
<h4 id="样例载入"><a href="#样例载入" class="headerlink" title="样例载入"></a>样例载入</h4><p>Logisim 的样例载入会略微复杂一点，需要修改 <code>.xml</code> 文件。其实你的 <code>.circ</code> 电路就是一种 <code>.xml</code> 文件，可以尝试用 VSCode 查看。</p>
<p>我们需要将机器码注入到 IFU 模块的 ROM 中。在 <code>.circ</code> 文件中定位到 ROM 处，“…”表示了机器码应当被填充的位置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">comp</span> <span class="hljs-attr">lib</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">loc</span>=<span class="hljs-string">&quot;(750,1020)&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ROM&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;addrWidth&quot;</span> <span class="hljs-attr">val</span>=<span class="hljs-string">&quot;12&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataWidth&quot;</span> <span class="hljs-attr">val</span>=<span class="hljs-string">&quot;32&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contents&quot;</span>&gt;</span>addr/data: 12 32<br><br>...<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">comp</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>我们可以使用<strong>正则表达式</strong>来匹配这一部分的内容，然后利用 <code>re.sub</code> 将匹配到的内容、机器码内容进行拼接，这样我们就成功注入了机器码。注意各个 32 位机器码间应该用空格分隔，亲身实践用 <code>\n</code> 分隔会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(machine_code_file, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        new_content = f.read()<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_a, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        circ_a = f.read()<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_b, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        circ_b = f.read()<br><br>    ptn = (<span class="hljs-string">r&#x27;(&lt;comp lib=&quot;\d+&quot; loc=&quot;\(\d+,\d+\)&quot; name=&quot;ROM&quot;&gt;&#x27;</span><br>           <span class="hljs-string">r&#x27;\s*&lt;a name=&quot;addrWidth&quot; val=&quot;\d+&quot;/&gt;&#x27;</span><br>           <span class="hljs-string">r&#x27;\s*&lt;a name=&quot;dataWidth&quot; val=&quot;\d+&quot;/&gt;&#x27;</span><br>           <span class="hljs-string">r&#x27;\s*&lt;a name=&quot;contents&quot;&gt;)[\s\S]*?(&lt;/a&gt;)&#x27;</span>)<br>  <br>    <span class="hljs-comment">#()中存放了两“块”正则匹配到的内容，match.group(1) 和 match.group(2) 分别对应这两块内容。</span><br><br>    <span class="hljs-keyword">match</span> = re.search(ptn, circ_a)<br>    <span class="hljs-comment">#我的电路中 ROM 地址宽度是 12 位，使用这个程序时注意地址宽度能否匹配</span><br>    replacement = <span class="hljs-keyword">match</span>.group(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;addr/data: 12 32\n&quot;</span> + new_content + <span class="hljs-string">&quot;\n&quot;</span> + <br>    <span class="hljs-keyword">match</span>.group(<span class="hljs-number">2</span>)<br>    new_circ_a = re.sub(ptn, replacement, circ_a)<br><br>    <span class="hljs-keyword">match</span> = re.search(ptn, circ_b)<br>    replacement = <span class="hljs-keyword">match</span>.group(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;addr/data: 12 32\n&quot;</span> + new_content + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-keyword">match</span>.group(<span class="hljs-number">2</span>)<br>    new_circ_b = re.sub(ptn, replacement, circ_b)<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_a, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(new_circ_a)<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_b, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(new_circ_b)<br></code></pre></td></tr></table></figure>

<p>Verilog 的样例载入就要简单很多。我们只需要将生成的机器码文件复制到与 Verilog 源代码在同一目录下的 <code>code.txt</code> 中，这一步还是通过命令行完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$copy</span> &#123;machine_code&#125;  &#123;injection_file&#125;<br></code></pre></td></tr></table></figure>

<h4 id="运行-CPU-并获得输出"><a href="#运行-CPU-并获得输出" class="headerlink" title="运行 CPU 并获得输出"></a>运行 CPU 并获得输出</h4><p>运行 Logisim 测试电路时，我们需要将我们搭建的 CPU 作为一个模块导入。<code>machine</code> 在这里即为 <code>logisim-generic-2.7.1.jar</code>，<code>testbench</code> 为测试电路文件名，<code>file_name</code> 为待评测电路文件的文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$java</span> -jar &#123;machine&#125; &#123;testbench&#125; -load &#123;file_name&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们以最快速度运行测试电路，以表格形式输出结果。表格中每一列代表一个输出端口在每一个时钟周期的输出值，每一列的具体含义取决于电路中端口的排列顺序。CO 平台上会要求你将输出端口按照给定顺序排列，因为评测时会直接比较你的电路输出的二进制文件是否与正确输出完全一致，若你的端口排列顺序不同，那么每一列的对应关系就“乱”了，评测自然也不会通过。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$java</span> -jar &#123;machine&#125; &#123;testbench&#125; -<span class="hljs-built_in">tty</span> table<br></code></pre></td></tr></table></figure>

<p>运行 Verilog 测试模块前，先要使用 Icarus Verilog 编译器将多个 Verilog 文件编译成一个可执行的仿真文件。<code>*.v</code> 会包含当前目录下所有的 Verilog 源文件，<code>-s</code> 参数告诉编译器哪个模块是测试的顶层模块，生成的输出文件 <code>.out</code> 是一个可以在终端直接运行的仿真程序。</p>
<blockquote>
<p>注意：这里的 <code>test_module_name</code> 应该是测试文件的<strong>模块名称</strong>，而不是测试文件的文件名。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">iverilog -s &#123;test_module_name&#125; -o &#123;test_module_name&#125;.out *.v<br></code></pre></td></tr></table></figure>

<p>然后运行仿真程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vvp &#123;test_module_name&#125;.out<br></code></pre></td></tr></table></figure>

<p>最后，别忘了把获得的输出写到输出文件中，这一步就交给大家自行完成。</p>
<h4 id="运行“魔改版”-MARS-获得输出"><a href="#运行“魔改版”-MARS-获得输出" class="headerlink" title="运行“魔改版” MARS 获得输出"></a>运行“魔改版” MARS 获得输出</h4><p>在 P3 的评测中这一步其实可以省略，我们可以直接对拍两份电路，然后比对输出的二进制文件。当然，由于“表格”中每一列对应关系明确，我们可以另外写一份解析程序来获得寄存器和内存的操作信息，与魔改版 MARS 的输出作比对。这一步骤相信对大家来说并不困难，这里就不提供代码了。</p>
<p>在 P3 和 P4 中，我们的 <code>add</code> 和 <code>sub</code> 指令并不考虑溢出异常，所以我们运行“魔改版” MARS 时也需要忽略溢出，命令行中 <code>ig</code> 参数就起到了这一作用。使用 <code>coL1</code> 参数能够输出对内存和寄存器的操作，<code>coL2</code> 参数能够获得更为详细的输出信息以便 debug，评测时我们只需要使用 <code>coL1</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$java</span> -jar &#123;machine&#125; &#123;file&#125; mc CompactLargeText coL1 ig<br></code></pre></td></tr></table></figure>

<h4 id="比较输出"><a href="#比较输出" class="headerlink" title="比较输出"></a>比较输出</h4><p>这一部分只需要对输出进行简单的比较。在 P3 和 P4 中，直接比较两份文件（测试模块输出、对拍对象输出）的输出是否相同就可以；P5 中由于同一时刻可能对内存、寄存器均有操作，所以对内存、寄存器的操作需要分开来比较。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>写到这里，评测机的构造也就慢慢清晰了——无非是数据生成、运行标准程序和待测程序、比较输出这几步，这也是评测机最为常见且容易实现的架构。</p>
<p>万事开头难，当你初次完成了评测机的搭建，“对拍”部分的代码一般就不会有大的变动了（至少对于 CO 课程来说如此），后续迭代只需要对“数据生成”代码进行调整。数据生成可以说是评测机的“灵魂”——评测效果如何，几乎全看数据强度如何。本文虽然介绍了如何随机生成数据，但是随机的数据并不能覆盖到所有的边界情况。<strong>随机生成结合“手搓”往往才是最优解</strong>。</p>
<p>希望这篇文章能够“抛砖引玉”，帮助大家搭建起自己的评测机。当你有了不错的评测机，意味着每次课下你都可以进行“强测”，能够尽量多地发现设计中的细节问题，从而可以将更能经受住考验的架构带到课上——上机时不用以 debug 课下“开局”，能将全部心思投入到新增指令上，“一遍过”这时不再是幻想。</p>
<p>希望在评测机的辅助下，大家能够准备好 bug-free 的设计，能够更有底气、更有自信地进入课上环节，顺利地推进上机测试。</p>
<p><strong>祝愿大家在计算机组成实验的道路上稳步前行！</strong></p>
]]></content>
      <categories>
        <category>计算机组成课下</category>
      </categories>
      <tags>
        <tag>计算机组成</tag>
        <tag>单周期 CPU</tag>
        <tag>CO 评测机</tag>
      </tags>
  </entry>
  <entry>
    <title>2025 年数据结构与程序设计（信息类）期中考试</title>
    <url>/2025/10/18/mid_test/</url>
    <content><![CDATA[<h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a><strong>选择题</strong></h3><ol>
<li><p>若双向链表结点类型定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">rlink</span>,*<span class="hljs-title">llink</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>那么在双向链表中，要在结点 <code>p</code>后插入结点 <code>s</code>，以下代码执行顺序正确的是：________。</p>
<span id="more"></span>

<p>①<code>s-&gt;llink=p;</code></p>
<p>②<code>p-&gt;rlink=s;</code></p>
<p>③<code>s-&gt;rlink=p-&gt;rlink;</code></p>
<p>④<code>p-&gt;rlink-&gt;llink=s;</code></p>
<p>A. ④②③①</p>
<p>B. ③①④②</p>
<p>C. ①③②④</p>
<p>D. ②④①③</p>
</li>
<li><p>以下哪一项是错误的结构体定义：________。</p>
<p>A.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> x,y;<br>&#125;Point;<br></code></pre></td></tr></table></figure>

<p>C.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">float</span> price;<br>    <span class="hljs-type">char</span> *name;<br>&#125;Book;<br></code></pre></td></tr></table></figure>

<p>D.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tree</span> <span class="hljs-title">neighbor</span>;</span><br>&#125;Tree;<br></code></pre></td></tr></table></figure></li>
<li><p>C语言中，想要获得指向 <code>int</code>类型数组 <code>a</code>中元素 <code>a[6]</code>的指针，以下写法正确的是：________。</p>
<p>A. <code>int* p = a+24;</code></p>
<p>B. <code>int* p = a+6;</code></p>
<p>C. <code>int* p = (&amp;a)+6;</code></p>
<p>D. <code>int* p = a[6]</code></p>
</li>
<li><p>以下声明二维数组的语句中，错误的是：________。</p>
<p>A. <code>int a[3][2] = &#123;1,2,3,4,5,6&#125;;</code></p>
<p>B. <code>int a[3][2] = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;</code></p>
<p>C. <code>int a[][2] = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;</code></p>
<p>D. <code>int a[3][] = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;</code></p>
</li>
<li><p>给定如下代码,则输出的结果为：________。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;hel/0lo\0world&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br></code></pre></td></tr></table></figure>

<p>A. <code>hel</code></p>
<p>B. <code>hello world</code></p>
<p>C. <code>hel/0lo</code></p>
<p>D. <code>hel/0lo\0world</code></p>
</li>
</ol>
<h3 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a><strong>填空题</strong></h3><ol>
<li><p>若单向链表结点类型定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如下代码实现了在单向链表的结点 <code>p</code>后删除一个非空结点的功能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">temp</span> =</span> p-&gt;next;<br>________;<br><span class="hljs-built_in">free</span>(temp);<br></code></pre></td></tr></table></figure>

<p>划线部分应该填写的语句是：________。</p>
</li>
<li><p>在二维数组 <code>a[3][3]=&#123;&#123;1,4,7&#125;,&#123;2,5,8&#125;,&#123;3,6,9&#125;&#125;;</code>中，元素 <code>a[2][1]</code>的值为________。</p>
</li>
<li><p>给定如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> value;<br>    ________ next;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果希望该结构体实现类似链表的数据结构，横线部分填写的内容是：________。</p>
</li>
<li><p>给定一个二维 <code>int</code>类型数组 <code>a</code>，则 <code>*(*(a+4)+2)</code>等价于访问该数组的元素________。</p>
</li>
<li><p>已知字符串 <code>char s1[] = &quot;apple&quot;; char s2[] = &quot;banana&quot;;</code>，则 <code>strcmp(s1,s2)</code>的值________0。（填“大于”，“等于”或“小于”）</p>
</li>
</ol>
<h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a><strong>编程题</strong></h3><p><strong>【问题描述】</strong></p>
<p>论文写作时经常需要引用前人的文献（称为参考文献），引用时要在论文中以特定的格式表示。一种在人文社科领域常用的论文引用和参考文献格式是“哈佛格式”，其示例如下：</p>
<p>There is a risk the traditional focus on intensification of agriculture to maximize yields under “normal” conditions may result in greater vulnerability of farms to climate extremes (Lin, 2008). Often management decisions more focused on minimizing variability or reducing recovery times in yields of perennial crops are reliant on enhanced ecological knowledge of a farm (Morel, 2019). Traditional smallholder systems often already use agroecological methods (Altieri, 2017), hence it is important for extension interventions to complement this knowledge.</p>
<p>本题要求处理一种简化版的“哈佛格式”，其特点是：</p>
<p>（1）对文献的引用信息以英文左括号作为开始，以英文右括号作为结束；</p>
<p>（2）作者姓名和出版年份一起标记一篇参考文献，作者和年份之间以英文逗号隔开，逗号之后有一个空格，例如：(Lin, 2008)；</p>
<p>（3）括号之内没有其他多余的空格。<br>本题要求分析上述“哈佛格式”的文本，提取文中的参考文献信息并按要求输出文献列表。</p>
<p><strong>【输入形式】</strong></p>
<p>从标准输入中读入一段规范的英文文本。注意：这里约定</p>
<p>（1）文本中圆括号里的内容都是参考文献，不会有其他内容；</p>
<p>（2）输入内容长度不超过10000字符，文本中间不会有换行符，文本的最后有换行符；</p>
<p>（3）引用的参考文献不超过100篇；</p>
<p>（4）作者姓名不超过31字符，区分大小写（若大小写不同，可当作不同作者处理）。</p>
<p><strong>【输出形式】</strong></p>
<p>输出文献列表，即作者姓名和出版年份列表：</p>
<p>（1）每篇文献输出一行，作者姓名和出版年份之间以一个空格隔开；</p>
<p>（2）按参考文献出现的先后次序输出；</p>
<p>（3）姓名和年份都一致的文献算一篇文章，只输出一次（按首次出现计算），不可重复输出。</p>
<p><strong>【样例输入】</strong></p>
<p>There is a risk the traditional focus on intensification of agriculture to maximize yields under “normal” conditions may result in greater vulnerability of farms to climate extremes (Lin, 2008). Often management decisions more focused on minimizing variability or reducing recovery times in yields of perennial crops are reliant on enhanced ecological knowledge of a farm (Morel, 2019). Traditional smallholder systems often already use agroecological methods (Altieri, 2017), hence it is important for extension interventions to complement this knowledge. Agroforestry systems are relatively common in smallholder systems and are considered an effective strategy for achieving climate resilient agriculture(Vaast, 2016), particularly to temper the impacts of climate shocks for understory crops(Tscharntke, 2011). During dry season conditions, shade trees ameliorate temperature extremes; however, they may not be able to maintain optimal humidity levels to the same extent as during wet seasons(Blaser, 2018). For low-input smallholder systems, leguminous trees, or those with symbiotic relationships with N2-fixing microbes, are an important source of nutrients and have been planted as shade trees(Blaser, 1998). However, the practice is limited due to costs(Vaast, 2016) and in some cases has caused mortality events during climate shocks by outcompeting under story crops for ground water(Abdulai, 2018).</p>
<p><strong>【样例输出】</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Lin</span> <span class="hljs-number">2008</span><br><span class="hljs-attribute">Morel</span> <span class="hljs-number">2019</span><br><span class="hljs-attribute">Altieri</span> <span class="hljs-number">2017</span><br><span class="hljs-attribute">Vaast</span> <span class="hljs-number">2016</span><br><span class="hljs-attribute">Tscharntke</span> <span class="hljs-number">2011</span><br><span class="hljs-attribute">Blaser</span> <span class="hljs-number">2018</span><br><span class="hljs-attribute">Blaser</span> <span class="hljs-number">1998</span><br><span class="hljs-attribute">Abdulai</span> <span class="hljs-number">2018</span><br></code></pre></td></tr></table></figure>

<p><strong>【样例说明】</strong></p>
<p>输入的文章有9处文献引用，但不同的参考文献只有8篇，因为参考文献(Vaast, 2016)被引用了两次，只按首次出现输出一次。</p>
<p><strong>【评分标准】</strong></p>
<p>该题考察标准输入输出和字符串处理，提交程序名为：hvref.c。</p>
<p><strong>【问题描述】</strong></p>
<p>一家银店会购入银块、卖出特定重量的白银，以及将散碎的白银熔合成大块。</p>
<p>请用链表形式模拟该店对白银的管理，每个链结点对应一个银块，记录该银块的重量（单位为克）；所有银块构成一个链表，且链表按照每个银块的重量始终保持升序排序。该链表允许如下操作：</p>
<p>（1）购入银块：将该银块按重量插入链表的合适位置；</p>
<p>（2）卖出m克白银：若m大于链表银块的总重量，则不处理（忽略该操作）；否则从链表第一个结点开始依次取出银块，直到取出银块的累计重量大于等于m为止。若取出的银块的累计重量大于m，则需要切割最后取出的银块，将切割后剩余银块放在链表的合适位置；</p>
<p>（3）熔合白银：将所有重量小于10克的银块熔为一块，并插入到链表的合适位置。</p>
<p>注意：不存在银块重量为0的链结点。</p>
<p><strong>【输入形式】</strong></p>
<p>从控制台输入由整数构成的序列，整数间以一个空格分隔，其中：</p>
<p>（1）正整数表示购入相应重量的银块；</p>
<p>（2）负整数表示卖出相应重量的白银；</p>
<p>（3）零表示熔合当前所有重量小于10克的散碎白银；</p>
<p>（4）数字999999表示输入结束。</p>
<p><strong>【输出形式】</strong></p>
<p>从链表头开始向控制台输出剩余银块的重量（正整数升序序列），各整数间以一个空格分隔，最后一个整数后有无空格均可。</p>
<p><strong>【样例输入】</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">10</span> -<span class="hljs-number">10</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> -<span class="hljs-number">20</span> <span class="hljs-number">5</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> -<span class="hljs-number">24</span> <span class="hljs-number">8</span> <span class="hljs-number">20</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">999999</span><br></code></pre></td></tr></table></figure>

<p><strong>【样例输出】</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">14</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure>

<p><strong>【样例说明】</strong></p>
<p>以上输入序列的含义为：购入10，卖出10，购入15，购入10，卖出20 （此时剩余银块为：5），购入5，购入20，购入30，卖出24（此时剩余银块为：6，30），购入8，购入20，熔合（此时银块为：14，20，30），购入5，结束。</p>
<p><strong>【评分标准】</strong></p>
<p>该题考察链表操作，提交程序名为：silver.c。</p>
]]></content>
      <categories>
        <category>试卷</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>信息类</tag>
        <tag>期中真题</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成 P7 课下——MIPS 微系统</title>
    <url>/2025/12/21/p7learn/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>在 P7 中，我们需要搭建一个简单的支持<strong>异常</strong>和<strong>中断</strong>的 MIPS 微系统。在之前的 Project 中，我们的 CPU 并没有考虑这些问题（例如： <code>add</code> 指令其实是按照 <code>addu</code> 实现的），但一个合格的处理器不能抛开这些问题不管。</p>
<span id="more"></span>

<p>P7 大约涉及以下几个方面的工作：</p>
<ol>
<li><p>在流水线各级检测指令异常，并将异常信息流水；</p>
</li>
<li><p>在 M 级添加协处理器 CP0；</p>
</li>
<li><p>添加 Bridge 实现 CPU 与外设的交互。</p>
</li>
<li><p>对流水线进行其他调整（清空逻辑、转发阻塞逻辑等）</p>
</li>
</ol>
<h3 id="异常检测与流水"><a href="#异常检测与流水" class="headerlink" title="异常检测与流水"></a>异常检测与流水</h3><p>按照指导书要求，P7 的异常分为“内部异常”和“外部中断”，其中<strong>后者优先级更高</strong>，这一点在编写 CP0 相关代码时需要注意。</p>
<h4 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h4><p>对于异常的检测，<strong>不能</strong>全部到 M 级（CP0 所在流水级）才检测。以 PC 不合法异常为例，如果我们不在 F 级检测这一异常并将指令机器码当作 0x00000000，我们的 CPU 就会尝试访问不合法的指令内存地址，这是不安全的。所以，最好尽早检测异常。</p>
<p>教程的异常代码表格中给出了多种异常，我们可以进行如下分类，在不同的流水级检测不同的异常。</p>
<table>
<thead>
<tr>
<th>检测流水级</th>
<th>异常类型</th>
</tr>
</thead>
<tbody><tr>
<td>F</td>
<td>PC 不合法</td>
</tr>
<tr>
<td>D</td>
<td>未知指令、Syscall</td>
</tr>
<tr>
<td>E</td>
<td>ALU 溢出（算术溢出 &#x2F; 读写地址计算溢出）</td>
</tr>
<tr>
<td>M</td>
<td>读写地址不合法</td>
</tr>
</tbody></table>
<h4 id="异常流水"><a href="#异常流水" class="headerlink" title="异常流水"></a>异常流水</h4><p>关于检测到的异常不可以直接提交到 CP0 的原因，教程中给出了详细解释，这里不赘述。在上一部分，我们在 M 级及之前的每一个流水级进行了异常检测，这里我们只需要将异常代码通过流水线寄存器进行流水。关于异常的流水，有两个注意点：</p>
<ol>
<li><p>对于不同的两条异常指令，先执行的指令的异常更优先（<strong>精确异常</strong>要求的体现）；</p>
</li>
<li><p>对于同一条指令的多个异常，在更靠前的流水级检出的异常更优先（<strong>尽早发现</strong>异常）。例如，一条指令在 F、D 级都被检出了异常，异常码以 F 级给出的为准，下面这段代码可以体现这一点。</p>
</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> D_exceptionCode = <br>(D_exceptionCodeTemp != <span class="hljs-number">1</span>) ? D_exceptionCodeTemp : <br>(D_Syscall) ? `cp0_Syscall :<br>(D_RI) ? `cp0_RI :<br><span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//D_exceptionCodeTemp 由 F_exceptionCode 流水而来</span><br></code></pre></td></tr></table></figure>

<h3 id="添加协处理器-CP0"><a href="#添加协处理器-CP0" class="headerlink" title="添加协处理器 CP0"></a>添加协处理器 CP0</h3><p>这里我选择将 CP0 放置在 <strong>M 级</strong>，因为异常判定涉及到对内存读写地址的判定。一般情况下，内存读写地址在 E 级 ALU 部件得出，经过 E → M 流水寄存器后传递给 M 级部件。因此，将 CP0 放在 M 级是更为方便的，这样一来不需要添加额外的转发通路。（大多数人会将 CP0 放置在 M 级，如果想要后续对拍方便，我建议“随大流”。）</p>
<h4 id="CP0-端口设计"><a href="#CP0-端口设计" class="headerlink" title="CP0 端口设计"></a>CP0 端口设计</h4><table>
<thead>
<tr>
<th>端口名</th>
<th>方向</th>
<th>位宽</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>in</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>in</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>writeEnable</td>
<td>in</td>
<td>1</td>
<td>是否写 CP0</td>
</tr>
<tr>
<td>CP0Addr</td>
<td>in</td>
<td>5</td>
<td>写 CP0 寄存器地址</td>
</tr>
<tr>
<td>CP0In</td>
<td>in</td>
<td>32</td>
<td>写入 CP0 的数据</td>
</tr>
<tr>
<td>CP0Out</td>
<td>out</td>
<td>32</td>
<td>从 CP0 读出的数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_PC</td>
<td>in</td>
<td>32</td>
<td>M 级 PC（宏观 PC）</td>
</tr>
<tr>
<td>BDIn</td>
<td>in</td>
<td>1</td>
<td>是否是延迟槽指令</td>
</tr>
<tr>
<td>ExcCodeIn</td>
<td>in</td>
<td>5</td>
<td>异常码</td>
</tr>
<tr>
<td>HWInt</td>
<td>in</td>
<td>6</td>
<td>外部中断信息，<code>&#123;&#123;3&#39;b000&#125;,&#123;interrupt&#125;,&#123;timer1IRQ&#125;,&#123;timer0IRQ&#125;&#125;</code></td>
</tr>
<tr>
<td>EXLClear</td>
<td>in</td>
<td>1</td>
<td>清空 EXL 位</td>
</tr>
<tr>
<td>EPCOut</td>
<td>out</td>
<td>32</td>
<td>受害 PC</td>
</tr>
<tr>
<td>Request</td>
<td>out</td>
<td>1</td>
<td>异常处理请求</td>
</tr>
<tr>
<td>externalInterruptRequest</td>
<td>out</td>
<td>1</td>
<td>是否响应外部中断器中断信号 <code>interrupt</code></td>
</tr>
</tbody></table>
<h4 id="异常处理请求"><a href="#异常处理请求" class="headerlink" title="异常处理请求"></a>异常处理请求</h4><p>异常处理请求的条件：发生外部中断或内部异常，且<strong>中断被允许</strong>。由于教程中给出的异常码表中不包含“1”，所以我用 <code>ExcCodeIn == 1</code> 表示无内部异常的情况。</p>
<ul>
<li><p>响应外部中断（INT）：</p>
<ol>
<li><p>全局中断使能（<code>SR[0] == 1</code>）</p>
</li>
<li><p>当前不在核心态（<code>SR[1] == 0</code>）</p>
</li>
<li><p>外部有中断且对应中断被允许（<code>HWInt &amp; SR[15:10] != 0</code>）</p>
</li>
</ol>
</li>
<li><p>响应内部异常（EXC）：  </p>
<ol>
<li><p>当前不在核心态（<code>SR[1] == 0</code>）</p>
</li>
<li><p>有内部异常（<code>ExcCodeIn != 1 &amp;&amp; ExcCodeIn != 0</code>）</p>
</li>
</ol>
</li>
</ul>
<h4 id="记录异常"><a href="#记录异常" class="headerlink" title="记录异常"></a>记录异常</h4><p>当检测到异常时，需要向 SR、Cause 和 EPC 寄存器中写入信息。对于每个寄存器的特定位，需要写入的信息如下：</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>位域</th>
<th>写入信息</th>
</tr>
</thead>
<tbody><tr>
<td>SR</td>
<td>1</td>
<td>写入 1，因为检测到异常</td>
</tr>
<tr>
<td>Cause</td>
<td>31</td>
<td>是延迟槽指令则写入 1</td>
</tr>
<tr>
<td>Cause</td>
<td>15:10</td>
<td>每周期更新，传入 <code>HWInt</code></td>
</tr>
<tr>
<td>Casue</td>
<td>6:2</td>
<td>异常码</td>
</tr>
<tr>
<td>EPC</td>
<td></td>
<td>受害 PC，注意延迟槽指令的受害 PC 为 M_PC - 4</td>
</tr>
</tbody></table>
<p>需要注意的是，由于外部中断优先级更高，则响应外部中断时，即使该指令有内部异常，也需要向 <code>Cause[6:2]</code> 中写入<strong>外部中断异常码</strong>。</p>
<h4 id="EXL-位清空"><a href="#EXL-位清空" class="headerlink" title="EXL 位清空"></a>EXL 位清空</h4><p>EXL 位置 1 代表强制进入核心态（执行异常处理程序），则当异常处理程序执行完成时，需要退出核心态。在 P7 中，<code>eret</code> 指令负责跳转到 EPC 执行接下来的主程序，所以 M 级检测到 <code>eret</code> 指令时（这个信号可以从 D 级流水过来），<code>EXLClear</code> 应当置 1，且 EXL 位应当被清空。</p>
<h4 id="CP0-的读写"><a href="#CP0-的读写" class="headerlink" title="CP0 的读写"></a>CP0 的读写</h4><p>与 D 级 GRF 部件的读写操作没有本质上不同，这里不再赘述。</p>
<h3 id="实现与外设的交互"><a href="#实现与外设的交互" class="headerlink" title="实现与外设的交互"></a>实现与外设的交互</h3><h4 id="系统桥"><a href="#系统桥" class="headerlink" title="系统桥"></a>系统桥</h4><p>系统桥 Bridge 需要实现对外设的读写操作。在这一部分，外设指两个 Timer。我们可以通过 Bridge 向 Timer 的特定寄存器（有对应地址）中写入数据，也可以从 Timer 读出数据（例如中断信号，HWInt 是需要的）。</p>
<table>
<thead>
<tr>
<th>端口名</th>
<th>方向</th>
<th>位宽</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>addrIn</td>
<td>in</td>
<td>32</td>
<td>写 Timer 的地址</td>
</tr>
<tr>
<td>dataIn</td>
<td>in</td>
<td>32</td>
<td>写 Timer 的数据</td>
</tr>
<tr>
<td>byteEnable</td>
<td>in</td>
<td>4</td>
<td>写对应地址的哪些字节</td>
</tr>
<tr>
<td>addrOut</td>
<td>out</td>
<td>32</td>
<td>连接 Timer 地址输入端</td>
</tr>
<tr>
<td>dataOut</td>
<td>out</td>
<td>32</td>
<td>连接 Timer 地址输出端</td>
</tr>
<tr>
<td>timerWrite0</td>
<td>out</td>
<td>1</td>
<td>连接 Timer0 写使能端</td>
</tr>
<tr>
<td>timerWrite1</td>
<td>out</td>
<td>1</td>
<td>连接 Timer1 写使能端</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>timerIn0</td>
<td>in</td>
<td>32</td>
<td>连接 Timer0 数据输出端</td>
</tr>
<tr>
<td>timerIn1</td>
<td>in</td>
<td>32</td>
<td>连接 Timer1 数据输出端</td>
</tr>
<tr>
<td>timerIRQIn0</td>
<td>in</td>
<td>32</td>
<td>连接 Timer0 中断输出端</td>
</tr>
<tr>
<td>timerIRQIn1</td>
<td>in</td>
<td>32</td>
<td>连接 Timer1 中断输出端</td>
</tr>
<tr>
<td>timerOut</td>
<td>in</td>
<td>32</td>
<td>从 Timer 读出的数据</td>
</tr>
<tr>
<td>timerIRQOut0</td>
<td>in</td>
<td>32</td>
<td>从 Timer0 读出的中断数据，传给 HWInt</td>
</tr>
<tr>
<td>timerIRQOut1</td>
<td>in</td>
<td>32</td>
<td>从 Timer1 读出的中断数据，传给 HWInt</td>
</tr>
</tbody></table>
<p>对于 <code>timerWrite0</code> 和 <code>timerWrite1</code> 的使能，直接通过写地址 <code>addrIn</code> 判断即可；输出的 <code>timerOut</code> 也是根据 <code>addrIn</code> 判断输出的是哪个 <code>Timer</code> 的对应数据。Bridge 的其他端口与 Timer 对应端口的接线可以直接参考仓库里的代码。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> timerWrite0 = <br>(addrIn &gt;= <span class="hljs-number">32&#x27;h00007f00</span> &amp;&amp; addrIn &lt;= <span class="hljs-number">32&#x27;h00007f0b</span> &amp;&amp; byteEnable != <span class="hljs-number">4&#x27;b0000</span>);<br><span class="hljs-keyword">assign</span> timerWrite1 = <br>(addrIn &gt;= <span class="hljs-number">32&#x27;h00007f10</span> &amp;&amp; addrIn &lt;= <span class="hljs-number">32&#x27;h00007f1b</span> &amp;&amp; byteEnable != <span class="hljs-number">4&#x27;b0000</span>);<br><span class="hljs-keyword">assign</span> timerOut = <br>(addrIn &gt;= <span class="hljs-number">32&#x27;h00007f00</span> &amp;&amp; addrIn &lt;= <span class="hljs-number">32&#x27;h00007f0b</span>) ? timerIn0:<br>(addrIn &gt;= <span class="hljs-number">32&#x27;h00007f10</span> &amp;&amp; addrIn &lt;= <span class="hljs-number">32&#x27;h00007f1b</span>) ? timerIn1:<br><span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<h4 id="响应中断发生器的中断"><a href="#响应中断发生器的中断" class="headerlink" title="响应中断发生器的中断"></a>响应中断发生器的中断</h4><p>按照教程，如果这时中断发生器产生中断（<code>interrupt == 1</code>）且允许响应外部中断器中断信号（<code>externalInterruptRequest == 1</code>），则写地址 0x7f20。官方提供了 <code>m_int_addr</code> 和 <code>m_int_byteen</code> 接口，直接更改对应输出数据即可：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> m_int_addr = m_data_addr;<br><span class="hljs-keyword">assign</span> m_int_byteen = <br>(M_externalInterruptResponse &amp;&amp; interrupt) ? <span class="hljs-number">4&#x27;b0001</span> : <span class="hljs-number">4&#x27;b0000</span>;<br></code></pre></td></tr></table></figure>

<p><code>externalInterruptRequest</code> 信号的置位逻辑与 <code>INT</code> 信号基本一致，但判断的是 <code>HWInt[2]</code> 和 <code>SR[12]</code> 是否均为 1。</p>
<h3 id="当异常请求（Request）到来时"><a href="#当异常请求（Request）到来时" class="headerlink" title="当异常请求（Request）到来时"></a>当异常请求（Request）到来时</h3><h4 id="PC-跳转"><a href="#PC-跳转" class="headerlink" title="PC 跳转"></a>PC 跳转</h4><p>此时 PC 应当跳转到 0x4180，修改 F 级 nextPC 模块即可。</p>
<h4 id="清空流水线"><a href="#清空流水线" class="headerlink" title="清空流水线"></a>清空流水线</h4><p>为了符合<strong>精确异常</strong>的要求，我们需要清空流水线——插入 <code>nop</code>，防止异常指令及其后续指令被真正执行产生影响。这一操作和 <code>reset</code> 时比较相像，不过由于异常处理程序从 0x4180 开始，所以 <code>request</code> 时，PC 应复位到 0x4180。</p>
<p>同时，异常码应该清空为“1”，即表示既没有外部中断（0），也没有内部异常。</p>
<h4 id="乘除模块"><a href="#乘除模块" class="headerlink" title="乘除模块"></a>乘除模块</h4><p>按照教程中要求，如果异常发生时 E 级有<strong>还没开始的</strong>涉及乘除模块的运算，则这一运算不应开始；若这一运算还没有执行到修改 HI、LO 寄存器的阶段，则不应当修改 HI、LO 寄存器。</p>
<p>只需要给 MDU 的工作条件增加 <code>!request</code> 即可：</p>
<ul>
<li><p>如果运算没有开始，此时运算所需数据不会被写入寄存器，<code>state</code> 不变，运算不能开始；</p>
</li>
<li><p>运算正在进行，还没写 HI、LO：由于此时 <code>request</code> 为高，MDU 的 <code>state</code> 不会改变，从而不会继续工作，不产生影响；</p>
</li>
</ul>
<h4 id="内存读写"><a href="#内存读写" class="headerlink" title="内存读写"></a>内存读写</h4><p>有异常或是 <code>request</code> 时都不应该对内存进行写入操作，以消除影响。</p>
<h3 id="当-eret-到来时"><a href="#当-eret-到来时" class="headerlink" title="当 eret 到来时"></a>当 <code>eret</code> 到来时</h3><p>我选择在 D 级 CTRL 模块检测当前指令是否为 <code>eret</code>。</p>
<ul>
<li><p>由于 <code>eret</code> 没有延迟槽，若 D 级检测到 <code>eret</code>，则 F 级需要插入一个 <code>nop</code> ——这是清空延迟槽最快捷的方法。</p>
</li>
<li><p>当 D 级检测到 <code>eret</code> 后，PC 需要跳转到 EPC 处，修改 F 级 nextPC 模块即可。</p>
</li>
</ul>
<h3 id="阻塞与转发"><a href="#阻塞与转发" class="headerlink" title="阻塞与转发"></a>阻塞与转发</h3><h4 id="eret-阻塞逻辑"><a href="#eret-阻塞逻辑" class="headerlink" title="eret 阻塞逻辑"></a><code>eret</code> 阻塞逻辑</h4><p><code>eret</code> 指令需要 EPC 中的数据。如果 <code>eret</code> 的前序指令需要写 EPC，则将 <code>eret</code> 阻塞在 D 级。</p>
<h4 id="阻塞时保留信息"><a href="#阻塞时保留信息" class="headerlink" title="阻塞时保留信息"></a>阻塞时保留信息</h4><p>这一点主要体现在 D → E 流水寄存器上。如果未发生 <code>reset</code> 和 <code>request</code>，而流水线被阻塞，需要保留 D 级的 PC 和 BD 信息。如果没有流水这两个信息会怎样？具体可以看下面这个例子来理解。</p>
<p>考虑指令序列 <code>lw - beq - add</code>，且 <code>add</code> 会因与 <code>lw</code> 产生数据冲突而被阻塞在 D 级。设想当前流水线各级的指令如下（带“*”表示延迟槽指令）：</p>
<table>
<thead>
<tr>
<th>F</th>
<th>D</th>
<th>E</th>
<th>M</th>
<th>W</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>add*</td>
<td>beq</td>
<td>lw</td>
<td></td>
</tr>
</tbody></table>
<p>由于阻塞，下一个时钟周期时流水线状态如下：</p>
<table>
<thead>
<tr>
<th>F</th>
<th>D</th>
<th>E</th>
<th>M</th>
<th>W</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>add*</td>
<td></td>
<td>beq</td>
<td>lw</td>
</tr>
</tbody></table>
<p>再下一个时钟周期的下降沿时来了一个中断。该周期时钟信号高电平时，流水线状态为：</p>
<table>
<thead>
<tr>
<th>F</th>
<th>D</th>
<th>E</th>
<th>M</th>
<th>W</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>add*</td>
<td></td>
<td></td>
<td>lw</td>
</tr>
</tbody></table>
<p>这时 CP0 需要记录异常相关信息。如果我们在阻塞时清空了 D → E 的所有信号，则获取到 M 级 PC 为 0x3000，BD 为 0，这显然是不正确的。因此，阻塞（且无 <code>reset</code> 和 <code>request</code>）时需要保留 PC 和 BD 信息。</p>
<p>优先级问题：请注意 <code>reset</code>，<code>request</code> 和 <code>stall</code> 信号的优先级关系依次从高到低，这一点在教程中有着重强调——复位高于一切，外部可见的请求高于不可见的阻塞。当 CPU 被封装，我们看不到内部流水线执行的细节，包括转发和阻塞，流水线的 CPU 在外人看来就仿佛是单周期的。</p>
<h4 id="转发逻辑"><a href="#转发逻辑" class="headerlink" title="转发逻辑"></a>转发逻辑</h4><p>可以考虑转发从 CP0 寄存器读出的数据。由于在 M 级才能访问 CP0 并更新数据，所以 $T_\text{new}&#x3D;3$，这与 <code>lw</code> 本质上区别不大（一个读 CP0，一个读内存），因此转发通路没有必要做特别改造。</p>
<h3 id="P7-思考题"><a href="#P7-思考题" class="headerlink" title="P7 思考题"></a>P7 思考题</h3><h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p><strong>请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</strong></p>
<p>CPU 通过总线和外部设备连接，输入信号会通过总线传递给 CPU。CPU 接收到中断信号后会进行处理，并反馈结果。</p>
<h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p><strong>请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</strong></p>
<p>设计上，要让用户不需要过多地考虑底层的实现，而是要让他们专注于“用户态”，这时底层指定中断异常处理地址是最为方便的选择。并且，若处理中断异常的程序由用户提供，由于用户并不知晓 CPU 的具体实现，其提供的处理代码可能会导致冒险问题，即使能够实现某些功能，但风险也很大。</p>
<h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><p><strong>为何与外设通信需要 Bridge？</strong></p>
<p>系统桥是连接 CPU 和外设的功能设备，它会给 CPU 提供一种接口，使得 CPU 可以像读写普通存储器一样（即按地址读写）来读写复杂多变的外设。系统桥统一且简化了 CPU 的对外接口，CPU 不必为每种外设单独提供接口，符合高内聚，低耦合的设计思想。尽管外设多种多样，但是 CPU 可以用统一的方法访问它们。</p>
<h4 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h4><p><strong>请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态转移图。</strong></p>
<pre><code class=" mermaid">graph LR
    A(IDLE)
    B(LOAD)
    C(CNT)
    D(INT)

    A --&gt; |ctrl_0 == 1; IRQ = 0| B
    A --&gt; |ctrl_0 == 0; IRQ = 0| A
    B --&gt; |无条件; IRQ = 0| C
    C --&gt; |ctrl_0 == 1, count &gt; 1; IRQ = 0| C
    C --&gt; |ctrl_0 == 1, count ≤ 1; IRQ = 0| D
    C --&gt; |ctrl_0 == 0| A
    D --&gt; |模式0：ctrl = 0; IRQ = 1|A
    D --&gt; |模式1：ctrl不变; IRQ = 0|A
</code></pre>

<h4 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h4><p><strong>倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</strong></p>
<p>若 CPU 该级所有信息均为空，携带的 PC 和延迟槽信息都可能是不正确的，这对异常信息的记录是很不利的；空泡中指令应该变为 <code>nop</code>，其他信息应保持与前一条指令一致，尤其是 PC 和 BD。</p>
<h4 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h4><p><strong>为什么 <code>jalr</code> 指令的两个寄存器不能相同，例如 <code>jalr $31, $31</code> ？</strong></p>
<p><code>$31</code> 的值更新和 PC 更新在同一时刻发生，我们对同一个寄存器同时读写，这种行为是“未定义”的。</p>
<h3 id="课下部分建议"><a href="#课下部分建议" class="headerlink" title="课下部分建议"></a>课下部分建议</h3><ul>
<li><p>尽早开始 P7 的工作，因为 P7 有一定理解难度，在高压、时间紧张的状况下可能很难完成任务。即使之前已经挂 P，但如果完全有可能推进到 P7 课下，请一定提前开始准备。</p>
</li>
<li><p>不要依赖课下测试，而是尝试自己另外构造新数据。异常部分的数据还算好构造，“力大砖飞”即可；中断部分的测试数据可以“小而精”，不用太长，覆盖到异常时中断、阻塞时中断等特别情况即可。我的<a href="https://github.com/kkdcymnj/buaa_co_2025/tree/main/cpu_check_p7/sample_manual">仓库</a>中有少量这样的数据，大家可以批判性地使用，注意更改 testbench 中 <code>target_pc</code> 值。</p>
</li>
<li><p>关于 debug 方面，如果已经验证 P6 功能能够正常实现，那么如果出现寄存器读写的错误，请考虑 CP0 部分、异常检测部分的实现。CP0 寄存器数据的特定位能给我们很大提示。例如，中测时出现了寄存器数据的第 31 位错误但其他位都正确，这时我们就可以考虑延迟槽指令的判定，因为对于延迟槽指令，<code>Cause[31] == 1</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成课下</category>
      </categories>
      <tags>
        <tag>计算机组成</tag>
        <tag>流水线 CPU</tag>
        <tag>MIPS 微系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成 P5 / P6 课下——流水线 CPU</title>
    <url>/2025/12/13/p5p6_learn/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>通过阅读这篇帖子，你能够学习到如何搭建一个流水线 CPU，并能对数据流水、阻塞、转发等重难点加以认识。由于 P5 和 P6 课下任务紧密关联，且 P6 课下任务代码量远小于 P5，所以这里将两次课下作业的学习内容合并到同一篇帖子中来讲述。</p>
<span id="more"></span>

<h3 id="任务概览"><a href="#任务概览" class="headerlink" title="任务概览"></a>任务概览</h3><p>从 P5 开始，我们需要搭建流水线 CPU，并最终在 P6 结束时实现如下表所示的指令。我对这些指令做了简单的归类（不过“类别”的名称可能并不准确），对于每一类指令的添加方法都是类似的。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>指令</th>
</tr>
</thead>
<tbody><tr>
<td>R 算数指令</td>
<td>add, sub, and, or, slt, sltu</td>
</tr>
<tr>
<td>I 算数指令</td>
<td>addi, andi, ori, lui</td>
</tr>
<tr>
<td>乘除指令</td>
<td>mult, multu, div, divu</td>
</tr>
<tr>
<td>与乘除相关的其他指令</td>
<td>mfhi, mflo, mthi, mtlo</td>
</tr>
<tr>
<td>Load 指令</td>
<td>lb, lh, lw</td>
</tr>
<tr>
<td>Store 指令</td>
<td>sb, sh, sw</td>
</tr>
<tr>
<td>分支指令</td>
<td>beq, bne</td>
</tr>
<tr>
<td>跳转链接指令</td>
<td>jal</td>
</tr>
<tr>
<td>跳回指令</td>
<td>jr</td>
</tr>
</tbody></table>
<p>我的流水线 CPU 采用了集中式译码，只需要在 D 级实例化 Controller 模块并得到几乎所有的控制信号，但是信号流水的代码量较大。也有很多同学采用了分布式译码，据说这种方式到 P7 会方便一点，大家可以自行选择。</p>
<h3 id="从单周期-CPU-出发"><a href="#从单周期-CPU-出发" class="headerlink" title="从单周期 CPU 出发"></a>从单周期 CPU 出发</h3><p>经过理论课程的学习，想必大家发现流水线 CPU 的架构和单周期 CPU 有诸多相似之处，这表示我们可以考虑直接将 P4 部分很多代码“移植”到本次作业中以减少负担。</p>
<p>我们来看一下 P4 中我们实现的模块以及它们在流水线 CPU 中所对应的流水级。可能你的设计和我的并不相同，但差异应该不会太大。</p>
<table>
<thead>
<tr>
<th>流水级</th>
<th>模块名称</th>
</tr>
</thead>
<tbody><tr>
<td>F</td>
<td>PC、NPC、IM</td>
</tr>
<tr>
<td>D</td>
<td>CTRL、EXT、GRF</td>
</tr>
<tr>
<td>E</td>
<td>ALU</td>
</tr>
<tr>
<td>M</td>
<td>DM</td>
</tr>
<tr>
<td>W</td>
<td>&#x2F;</td>
</tr>
</tbody></table>
<p>下面我们来分析一下从单周期 CPU 到流水线 CPU 的“变与不变”：</p>
<ul>
<li>F 级：涉及 PC 跳转以及取指令，这在流水线 CPU 中变化不大（但还是有细节差异，见下文）</li>
<li>D 级：涉及译码、立即数扩展、写寄存器，主要的变化还是在译码（可能要译出更多信号）</li>
<li>E 级：涉及运算，且单周期 CPU 中，我们通过 <code>sub</code> 运算完成 <code>beq</code> 逻辑。不过在流水线 CPU 中，我们要将<strong>分支提前到 D 级</strong>，所以 <code>beq</code> 的逻辑要从 ALU 中剥离，且我们需要在 D 级建立 CMP 模块执行 <code>beq</code> 及其类似指令</li>
<li>M 级：读写内存，变化不大</li>
<li>W 级：新增部分，接受 M 级传出的最终确认的<strong>正确</strong>信号，并完成对 D、E、M 级的数据转发</li>
<li>流水寄存器：F → D、D → E、E → M、M → W 的<strong>信号流水</strong>，这是 P5 的重点工作</li>
</ul>
<p>到这里我们应该大致对 P5 的工作有了一定认识。话不多说，开干！</p>
<h3 id="完成各流水级模块"><a href="#完成各流水级模块" class="headerlink" title="完成各流水级模块"></a>完成各流水级模块</h3><h4 id="F-级"><a href="#F-级" class="headerlink" title="F 级"></a>F 级</h4><p>PC</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>1</td>
<td>input</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>1</td>
<td>input</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>nextPC</td>
<td>32</td>
<td>input</td>
<td>传入下一个 PC 值</td>
</tr>
<tr>
<td>currentPC</td>
<td>32</td>
<td>output</td>
<td>传出当前 PC 值</td>
</tr>
</tbody></table>
<p>IM</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>currentPC</td>
<td>32</td>
<td>input</td>
<td>当前 PC 值</td>
</tr>
<tr>
<td>Instr</td>
<td>32</td>
<td>output</td>
<td>当前指令</td>
</tr>
</tbody></table>
<p>NPC</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>currentPC</td>
<td>32</td>
<td>input</td>
<td>当前 PC 值</td>
</tr>
<tr>
<td>stall</td>
<td>1</td>
<td>input</td>
<td>是否阻塞</td>
</tr>
<tr>
<td>offset</td>
<td>16</td>
<td>input</td>
<td>分支指令所用的 offset</td>
</tr>
<tr>
<td>PC_from_rs</td>
<td>32</td>
<td>input</td>
<td>rs 寄存器中存储的地址</td>
</tr>
<tr>
<td>instr_index</td>
<td>26</td>
<td>input</td>
<td>26 位立即数（跳转使用）</td>
</tr>
<tr>
<td>nextPCSel</td>
<td>3</td>
<td>input</td>
<td>控制下一个 PC 值来源</td>
</tr>
<tr>
<td>nextPC</td>
<td>32</td>
<td>output</td>
<td>下一个 PC 值</td>
</tr>
</tbody></table>
<p>虽然 NPC 在 F 级，但 nextPC 的决定取决于 D 级 CTRL 部分信号。为便于理解，我们可以设想如下的场景：</p>
<table>
<thead>
<tr>
<th>F</th>
<th>D</th>
<th>E</th>
<th>M</th>
<th>W</th>
</tr>
</thead>
<tbody><tr>
<td>指令 2</td>
<td>※指令 1（目前关心的指令）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>F_PC</td>
<td>D_PC</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>正常情况下，随着指令 1 进入 D 级，指令 2 会随之进入 F 级，这样一来，执行指令 1 意味着一定会执行紧随其后的指令 2，这就实现了<strong>延迟槽</strong>。在不需要跳转、分支的情况下，这一定程度地提高了流水线效率。</p>
<p>从图上我们可以直观地看到，F_PC &#x3D; D_PC + 4。下面我们来讨论如何决定 nextPC：</p>
<ul>
<li>指令 1 不是分支、跳转指令：顺序执行，nextPC &#x3D; F_PC + 4</li>
<li>指令 1 是分支指令：若分支条件成立，nextPC &#x3D; D_PC + 4 + signExt(offset || $0^2$) &#x3D; F_PC + signExt(offset || $0^2$) ；若分支条件不成立，顺序执行，nextPC &#x3D; F_PC + 4</li>
<li>指令 1 是跳转指令：PC 跳转到 D_PC[31:28] || instr_index || $0^2$，若链接，则向对应寄存器写入 F_PC + 4 &#x3D; D_PC + 8，这是指令 2 紧跟着的下一条指令的 PC</li>
<li>指令 1 是跳回指令：PC 跳转到 rs 寄存器中的值</li>
</ul>
<h4 id="D-级"><a href="#D-级" class="headerlink" title="D 级"></a>D 级</h4><p>Splitter</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Instr</td>
<td>32</td>
<td>input</td>
<td>当前指令</td>
</tr>
<tr>
<td>opCode</td>
<td>6</td>
<td>output</td>
<td>机器码 [31:26] 位</td>
</tr>
<tr>
<td>funct</td>
<td>6</td>
<td>output</td>
<td>机器码 [5:0] 位</td>
</tr>
<tr>
<td>rs</td>
<td>5</td>
<td>output</td>
<td>机器码 [25:21] 位，源寄存器</td>
</tr>
<tr>
<td>rt</td>
<td>5</td>
<td>output</td>
<td>机器码 [20:16] 位，目标寄存器</td>
</tr>
<tr>
<td>rd</td>
<td>5</td>
<td>output</td>
<td>机器码 [15:11] 位，目的寄存器</td>
</tr>
<tr>
<td>shamt</td>
<td>5</td>
<td>output</td>
<td>机器码 [10:6] 位，移位值</td>
</tr>
<tr>
<td>immediate16</td>
<td>16</td>
<td>output</td>
<td>I 型指令立即数（16 位）</td>
</tr>
<tr>
<td>immediate26</td>
<td>26</td>
<td>output</td>
<td>J 型指令立即数（26 位）</td>
</tr>
</tbody></table>
<p>CTRL</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>opCode</td>
<td>6</td>
<td>input</td>
<td>机器码 [31:26] 位</td>
</tr>
<tr>
<td>funct</td>
<td>6</td>
<td>input</td>
<td>机器码 [5:0] 位</td>
</tr>
<tr>
<td>Tuse_rs</td>
<td>3</td>
<td>output</td>
<td>rs 寄存器的$T_\text{use}$</td>
</tr>
<tr>
<td>Tuse_rt</td>
<td>3</td>
<td>output</td>
<td>rt 寄存器的$T_\text{use}$</td>
</tr>
<tr>
<td>Tnew</td>
<td>3</td>
<td>output</td>
<td>指令$T_\text{new}$</td>
</tr>
<tr>
<td>nextPCSel</td>
<td>3</td>
<td>output</td>
<td>控制 nextPC 的来源</td>
</tr>
<tr>
<td>cmpOp</td>
<td>1</td>
<td>output</td>
<td>比较类型，相等比较（0），不等比较（1）</td>
</tr>
<tr>
<td>extOp</td>
<td>1</td>
<td>output</td>
<td>立即数扩展方式，零扩展（0），符号扩展（1）</td>
</tr>
<tr>
<td>ALU_ASrc</td>
<td>2</td>
<td>output</td>
<td>控制操作数 A 的来源</td>
</tr>
<tr>
<td>ALU_BSrc</td>
<td>2</td>
<td>output</td>
<td>控制操作数 B 的来源</td>
</tr>
<tr>
<td>ALUOp</td>
<td>4</td>
<td>output</td>
<td>控制 ALU 进行的运算类型</td>
</tr>
<tr>
<td>MemWrite</td>
<td>1</td>
<td>output</td>
<td>是否需要写数据存储器</td>
</tr>
<tr>
<td>MemDataType</td>
<td>2</td>
<td>output</td>
<td>写入数据存储器的数据类型，word（0），half（1），byte（2）</td>
</tr>
<tr>
<td>MemOutSigned</td>
<td>1</td>
<td>output</td>
<td>读出数据存储器的数据需要零扩展（0），符号扩展（1）</td>
</tr>
<tr>
<td>RegWrite</td>
<td>1</td>
<td>output</td>
<td>是否需要写寄存器</td>
</tr>
<tr>
<td>RegWriteAddrSel</td>
<td>2</td>
<td>output</td>
<td>将数据写入哪个寄存器</td>
</tr>
<tr>
<td>RegWriteDataSrc</td>
<td>2</td>
<td>output</td>
<td>控制写入寄存器的数据来源</td>
</tr>
</tbody></table>
<p>Tuse 和 Tnew 信号的作用在“阻塞与转发”部分会详细说明。其他信号的作用请见“描述”一栏。</p>
<p>GRF</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>1</td>
<td>input</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>1</td>
<td>input</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>writeEnable</td>
<td>1</td>
<td>input</td>
<td>寄存器使能信号</td>
</tr>
<tr>
<td>A1</td>
<td>5</td>
<td>input</td>
<td>第一个读寄存器地址</td>
</tr>
<tr>
<td>A2</td>
<td>5</td>
<td>input</td>
<td>第二个读寄存器地址</td>
</tr>
<tr>
<td>A3</td>
<td>5</td>
<td>input</td>
<td>写寄存器地址</td>
</tr>
<tr>
<td>writeData</td>
<td>32</td>
<td>input</td>
<td>写入数据</td>
</tr>
<tr>
<td>currentPC</td>
<td>32</td>
<td>input</td>
<td>当前 PC 值</td>
</tr>
<tr>
<td>RD1</td>
<td>32</td>
<td>output</td>
<td>第一个寄存器值</td>
</tr>
<tr>
<td>RD2</td>
<td>32</td>
<td>output</td>
<td>第二个寄存器值</td>
</tr>
</tbody></table>
<p>CMP</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RD1</td>
<td>32</td>
<td>input</td>
<td>第一个操作数</td>
</tr>
<tr>
<td>RD2</td>
<td>32</td>
<td>input</td>
<td>第二个操作数</td>
</tr>
<tr>
<td>cmpOp</td>
<td>4</td>
<td>input</td>
<td>比较方案</td>
</tr>
<tr>
<td>flag</td>
<td>1</td>
<td>output</td>
<td>是否满足条件</td>
</tr>
</tbody></table>
<p>EXT</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>immediate</td>
<td>16</td>
<td>input</td>
<td>输入立即数（16 位）</td>
</tr>
<tr>
<td>extOp</td>
<td>1</td>
<td>input</td>
<td>扩展方式，零扩展（0），符号扩展（1）</td>
</tr>
<tr>
<td>extended</td>
<td>32</td>
<td>output</td>
<td>扩展后的立即数</td>
</tr>
</tbody></table>
<h4 id="E-级"><a href="#E-级" class="headerlink" title="E 级"></a>E 级</h4><p>ALU</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>32</td>
<td>input</td>
<td>操作数一</td>
</tr>
<tr>
<td>B</td>
<td>32</td>
<td>input</td>
<td>操作数二</td>
</tr>
<tr>
<td>ALUOp</td>
<td>4</td>
<td>input</td>
<td>ALU 进行的运算</td>
</tr>
<tr>
<td>result</td>
<td>32</td>
<td>output</td>
<td>运算结果</td>
</tr>
</tbody></table>
<h4 id="M-级"><a href="#M-级" class="headerlink" title="M 级"></a>M 级</h4><p>DM</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>1</td>
<td>input</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>1</td>
<td>input</td>
<td>同步复位信号</td>
</tr>
<tr>
<td>writeEnable</td>
<td>1</td>
<td>input</td>
<td>写使能</td>
</tr>
<tr>
<td>address</td>
<td>32</td>
<td>input</td>
<td>操作地址</td>
</tr>
<tr>
<td>writeData</td>
<td>32</td>
<td>input</td>
<td>写入数据</td>
</tr>
<tr>
<td>dataType</td>
<td>2</td>
<td>input</td>
<td>写入数据的类型</td>
</tr>
<tr>
<td>isSigned</td>
<td>1</td>
<td>input</td>
<td>是否为有符号数</td>
</tr>
<tr>
<td>currentPC</td>
<td>32</td>
<td>input</td>
<td>当前 PC 值</td>
</tr>
<tr>
<td>readData</td>
<td>32</td>
<td>output</td>
<td>读出数据</td>
</tr>
</tbody></table>
<h4 id="W-级"><a href="#W-级" class="headerlink" title="W 级"></a>W 级</h4><p>除了 M → W 流水寄存器，没有需要“实例化”的模块。在“转发”部分 W 级会发挥它真正的作用。</p>
<h3 id="让信号流水起来"><a href="#让信号流水起来" class="headerlink" title="让信号流水起来"></a>让信号流水起来</h3><p>这一步可以说是 P5 的半壁江山。方便起见，这里我只列出每一级所需要的信号。信号流水这一块的代码确实比较繁琐，不过你可以先写好输入输出接口，让大模型补全流水代码，再辅以人工检查。</p>
<p>注意信号流水的完整性，每一个信号都要完整地流水到被需要的流水级，这一部分在课下测试中请一定做好全面检查。流水中会涉及到 Tuse 和 Tnew 信号，具体用途见“阻塞与转发”。</p>
<h4 id="D-级-1"><a href="#D-级-1" class="headerlink" title="D 级"></a>D 级</h4><table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>D_PC</td>
<td>32</td>
<td>output</td>
<td>D 级的 PC 值</td>
</tr>
<tr>
<td>D_PCwith4</td>
<td>32</td>
<td>output</td>
<td>D 级的 PC + 4 值</td>
</tr>
<tr>
<td>D_PCwith8</td>
<td>32</td>
<td>output</td>
<td>D 级的 PC + 8 值</td>
</tr>
<tr>
<td>D_Instr</td>
<td>32</td>
<td>output</td>
<td>D 级的指令</td>
</tr>
</tbody></table>
<p>这些信号用于 D 级的译码以及 F 级 PC 跳转、后续各级 PC 的写入。</p>
<h4 id="E-级-1"><a href="#E-级-1" class="headerlink" title="E 级"></a>E 级</h4><table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>E_rsVal</td>
<td>32</td>
<td>output</td>
<td>E 级 rs 寄存器内的值</td>
</tr>
<tr>
<td>E_rtVal</td>
<td>32</td>
<td>output</td>
<td>E 级 rt 寄存器内的值</td>
</tr>
<tr>
<td>E_extended</td>
<td>32</td>
<td>output</td>
<td>E 级扩展后的立即数</td>
</tr>
<tr>
<td>E_shamt</td>
<td>32</td>
<td>output</td>
<td>E 级移位值</td>
</tr>
<tr>
<td>E_ALU_ASel</td>
<td>2</td>
<td>output</td>
<td>E 级控制 ALU 第一个操作数</td>
</tr>
<tr>
<td>E_ALU_BSel</td>
<td>2</td>
<td>output</td>
<td>E 级控制 ALU 第二个操作数</td>
</tr>
<tr>
<td>E_ALUOp</td>
<td>4</td>
<td>output</td>
<td>E 级控制 ALU 运算</td>
</tr>
<tr>
<td>E_Tnew</td>
<td>3</td>
<td>input</td>
<td>E 级$T_\text{new}$ 值</td>
</tr>
</tbody></table>
<p>这些信号用于 E 级完成运算工作，所以我们需要向 E 级传入操作数、ALUOp 等关键信号。</p>
<h4 id="M-级-1"><a href="#M-级-1" class="headerlink" title="M 级"></a>M 级</h4><table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>M_rtVal</td>
<td>32</td>
<td>output</td>
<td>M 级 rt 寄存器内的值</td>
</tr>
<tr>
<td>M_ALUOut</td>
<td>32</td>
<td>output</td>
<td>M 级 ALU 运算结果</td>
</tr>
<tr>
<td>M_MemWrite</td>
<td>1</td>
<td>output</td>
<td>M 级控制是否写数据存储器</td>
</tr>
<tr>
<td>M_MemDataType</td>
<td>2</td>
<td>output</td>
<td>M 级控制写入数据存储器的数据类型</td>
</tr>
<tr>
<td>M_MemOutSigned</td>
<td>1</td>
<td>output</td>
<td>M 级控制读出数据存储器的数据需要零扩展（0），符号扩展（1）</td>
</tr>
<tr>
<td>M_Tnew</td>
<td>3</td>
<td>output</td>
<td>M 级$T_\text{new}$ 值</td>
</tr>
</tbody></table>
<p>对于 store 指令，rtVal 是写入值；对于存取指令，ALUOut 是内存操作地址；MemDataType 和 MemOutSigned 是我超前预留的信号，在 P6 中会有些用处。</p>
<h4 id="W-级-1"><a href="#W-级-1" class="headerlink" title="W 级"></a>W 级</h4><table>
<thead>
<tr>
<th>端口</th>
<th>位宽</th>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>W_RegWrite</td>
<td>1</td>
<td>output</td>
<td>W 级是否写寄存器</td>
</tr>
<tr>
<td>W_RegWriteAddr</td>
<td>5</td>
<td>output</td>
<td>W 级写入寄存器的编号</td>
</tr>
<tr>
<td>W_RegWriteDataSrc</td>
<td>2</td>
<td>output</td>
<td>W 级控制写入寄存器的数据来源</td>
</tr>
<tr>
<td>W_ALUOut</td>
<td>32</td>
<td>output</td>
<td>W 级 ALU 运算结果</td>
</tr>
<tr>
<td>W_DMOut</td>
<td>32</td>
<td>output</td>
<td>W 级 DM 读出数据</td>
</tr>
<tr>
<td>W_PC</td>
<td>32</td>
<td>output</td>
<td>W 级 PC 值</td>
</tr>
<tr>
<td>W_PCwith4</td>
<td>32</td>
<td>output</td>
<td>W 级 PC + 4 结果</td>
</tr>
<tr>
<td>W_PCwith8</td>
<td>32</td>
<td>output</td>
<td>W 级 PC + 8 结果</td>
</tr>
</tbody></table>
<p>在 W 级我们要处理写寄存器的操作了。D 级 GRF 的写入使能、写入地址、写入数据正常情况下均来源于 W 级。根据最终可能的写入寄存器的数据来源，我们都进行了信号流水。</p>
<h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><table>
<thead>
<tr>
<th>信号名称</th>
<th>最初生成的流水级</th>
<th>最终到达的流水级</th>
</tr>
</thead>
<tbody><tr>
<td>PC</td>
<td>F</td>
<td>W</td>
</tr>
<tr>
<td>PCwith4</td>
<td>F</td>
<td>W</td>
</tr>
<tr>
<td>PCwith8</td>
<td>F</td>
<td>W</td>
</tr>
<tr>
<td>Instr</td>
<td>F</td>
<td>W</td>
</tr>
<tr>
<td>rsVal</td>
<td>D</td>
<td>E</td>
</tr>
<tr>
<td>rtVal</td>
<td>D</td>
<td>M</td>
</tr>
<tr>
<td>extended</td>
<td>D</td>
<td>E</td>
</tr>
<tr>
<td>shamt</td>
<td>D</td>
<td>E</td>
</tr>
<tr>
<td>ALU_ASrc</td>
<td>D</td>
<td>E</td>
</tr>
<tr>
<td>ALU_BSrc</td>
<td>D</td>
<td>E</td>
</tr>
<tr>
<td>ALUOp</td>
<td>D</td>
<td>E</td>
</tr>
<tr>
<td>ALUOut</td>
<td>E</td>
<td>W</td>
</tr>
<tr>
<td>MemWrite</td>
<td>D</td>
<td>M</td>
</tr>
<tr>
<td>MemDataType</td>
<td>D</td>
<td>M</td>
</tr>
<tr>
<td>MemOutSigned</td>
<td>D</td>
<td>M</td>
</tr>
<tr>
<td>RegWrite</td>
<td>D</td>
<td>W</td>
</tr>
<tr>
<td>RegWriteAddr</td>
<td>D</td>
<td>W</td>
</tr>
<tr>
<td>RegWriteDataSrc</td>
<td>D</td>
<td>W</td>
</tr>
</tbody></table>
<p>这些控制信号在何处生成、最终到达何处是一个值得认真思考的问题。上表中列出了正常情况下各个信号流水的路径。在课上新增指令时，这些路径可能会发生比较明显的变化，这也是 P5、P6 课上的一个重要难点。</p>
<h3 id="处理冒险——添加阻塞与转发"><a href="#处理冒险——添加阻塞与转发" class="headerlink" title="处理冒险——添加阻塞与转发"></a>处理冒险——添加阻塞与转发</h3><p>按照教程要求，这里我们使用 AT 法处理阻塞与转发。</p>
<h4 id="确定-T-text-use-和-T-text-new"><a href="#确定-T-text-use-和-T-text-new" class="headerlink" title="确定 $T_\text{use}$ 和 $T_\text{new}$"></a>确定 $T_\text{use}$ 和 $T_\text{new}$</h4><ul>
<li>$T_\text{use}$：从 <strong>D 级</strong>开始，还需要多少时钟周期会使用到这个寄存器的数据。<strong>对于指令中涉及到的源寄存器，都有对应的 $T_\text{use}$ 值。</strong></li>
<li>$T_\text{new}$：从<strong>当前流水级</strong>开始，还需要多少时钟周期能够得出写回寄存器的正确数据。注意这不同于“还需多少周期正确数据写回寄存器”。<strong>D、E、M、W 级都有对应的 $T_\text{new}$ 值。</strong></li>
</ul>
<p>下面我们引入几个简单的例子来看看如何确定这两个参数。</p>
<ul>
<li><code>add rd, rs, rt</code>：rs 和 rt 寄存器数据在 E 级 ALU 模块使用，距离 D 级 1 个周期，rs 和 rt 的 $T_\text{use}$ 均为 1；正确结果在 E 级 ALU 模块计算出来，但是教程要求<strong>不可以从部件直接转发数据</strong>，所以计算结果<strong>经 E → M 流水寄存器到 M 级后才能转发</strong>，相当于从 D 级开始需要 2 周期（E 级开始需要 1 周期，M 级开始需要 0 周期）得到正确的写回 rd 的数据，各级 $T_\text{new}$ 依次为 2，1，0，0。</li>
<li><code>beq rs, rt, label</code>：rs 和 rt 寄存器数据在 D 级 CMP 模块使用，距离 D 级 0 个周期，rs 和 rt 的 $T_\text{use}$ 均为 0；没有寄存器的数据要被更新，D 级及以后的 $T_\text{new}$ 均为 0。</li>
<li><code>lw rt, base(offset)</code>：rs 寄存器在 E 级被使用来计算内存地址，$T_\text{use}&#x3D; 1$；rt 寄存器在 M 级被写入数据，$T_\text{use}&#x3D; 2$；M 级为 rt 提供了正确的新数据，但这一数据<strong>流水到 W 级后才能转发</strong>，相当于从 D 级开始需要 3 周期（E 级开始需要 2 周期，M 级开始需要 1 周期，W 级开始需要 0 周期）得到正确的写回 rt 的数据，各级 $T_\text{new}$ 依次为 3，2，1，0。</li>
<li><code>lui rt, immediate</code>：其他分析类似 <code>add</code> 指令。不过，<code>lui</code> 指令不使用 rs 寄存器，可以认为 rs 对应的 $T_\text{use}$ 为无穷大。实际代码中，为 $T_\text{use}$ 赋一个较大的数即可。</li>
</ul>
<p>这样我们就可以得到 $T_\text{use}$ 和 $T_\text{new}$ 与指令的对照表。为节省空间，这里我只列出了 P5 部分需要用到的指令，P6 部分新增指令可以类似地添加：</p>
<table>
<thead>
<tr>
<th></th>
<th>$T_\text{use}$ for rs</th>
<th>$T_\text{use}$ for rt</th>
<th>$T_\text{new}$</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>sub</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>ori</td>
<td>1</td>
<td>7</td>
<td>2</td>
</tr>
<tr>
<td>lw</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>sw</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>beq</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>lui</td>
<td>1</td>
<td>7</td>
<td>2</td>
</tr>
<tr>
<td>nop</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>jal</td>
<td>7</td>
<td>7</td>
<td>0</td>
</tr>
<tr>
<td>jr</td>
<td>7</td>
<td>7</td>
<td>0</td>
</tr>
</tbody></table>
<h4 id="阻塞逻辑"><a href="#阻塞逻辑" class="headerlink" title="阻塞逻辑"></a>阻塞逻辑</h4><p>若当前指令需要用到某个寄存器的数据，但前序指令还没有获得写入这个寄存器的正确数据，则把当前指令<strong>阻塞于 D 级</strong>。前序指令处于 E、M 级时这种情况都会发生。</p>
<p>上面这句话有些拗口，我们把其中涉及到的阻塞条件拆开来写。假设当前指令需要用到的寄存器地址为 <code>cur_addr</code>，前序指令要写的寄存器地址为 <code>pre_addr</code>：</p>
<ul>
<li>当前寄存器 $T_\text{use}$ 小于前序指令所在流水级的 $T_\text{new}$。原因很明显，此时还没能获得“正确数据”；</li>
<li><code>cur_addr</code> &#x3D; <code>pre_addr</code>。不过，如果二者都为 0 则不需要阻塞，因为 0 号寄存器内的数据应始终为 0 不改变；</li>
<li>前序指令<strong>要写</strong> <code>pre_addr</code> 寄存器。这会带来数据的更新，导致后续指令用到的数据不正确。如果前序指令<strong>不写</strong>，则不需要阻塞，因为这不带来数据改变。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> stall_from_E =<br>(E_RegWrite &amp;&amp; (rs == E_RegWriteAddr &amp;&amp; rs!=<span class="hljs-number">0</span>) &amp;&amp; (Tuse_rs &lt; E_Tnew) ) ||<br>(E_RegWrite &amp;&amp; (rt == E_RegWriteAddr &amp;&amp; rt!=<span class="hljs-number">0</span>) &amp;&amp; (Tuse_rt &lt; E_Tnew) ) ;<br><br><span class="hljs-keyword">wire</span> stall_from_M =<br>(M_RegWrite &amp;&amp; (rs == M_RegWriteAddr &amp;&amp; rs!=<span class="hljs-number">0</span>) &amp;&amp; (Tuse_rs &lt; M_Tnew) ) ||<br>(M_RegWrite &amp;&amp; (rt == M_RegWriteAddr &amp;&amp; rt!=<span class="hljs-number">0</span>) &amp;&amp; (Tuse_rt &lt; M_Tnew) );<br></code></pre></td></tr></table></figure>

<h4 id="转发逻辑"><a href="#转发逻辑" class="headerlink" title="转发逻辑"></a>转发逻辑</h4><p>在 E、M 级的部件能够产生“正确结果”，但是这些结果需要经过一道流水级寄存器再转发，也就是说，转发的情况应当发生在 M、W 级。当 M、W 级同时都可以转发，M 级的数据应更优先，因为处在 M 级的指令是<strong>更新近</strong>的。</p>
<p>假设当前指令需要用到的寄存器地址为 <code>cur_addr</code>，前序指令要写的寄存器地址为 <code>pre_addr</code>，则发生转发需要满足：</p>
<ul>
<li>前序指令所在流水级的 $T_\text{new}&#x3D;0$。在这时写入寄存器的“正确数据”已经产生；</li>
<li><code>cur_addr</code> &#x3D; <code>pre_addr</code>。不过，如果二者都为 0 则不需要转发，因为 0 号寄存器内的数据应始终为 0 不改变；</li>
<li>前序指令<strong>要写</strong> <code>pre_addr</code> 寄存器。这会带来数据的更新，只有转发更新后的数据我们才能保证当前指令使用了正确的寄存器数据，指令执行才不会出错。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sel = <br>(RegAddr == M_RegWriteAddr &amp;&amp; M_RegWriteAddr!=<span class="hljs-number">0</span> &amp;&amp; M_RegWrite &amp;&amp; M_Tnew==<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">new</span>==<span class="hljs-number">0</span>)? <span class="hljs-number">2&#x27;b10</span>:<br>(RegAddr == W_RegWriteAddr &amp;&amp; W_RegWriteAddr!=<span class="hljs-number">0</span> &amp;&amp; W_RegWrite &amp;&amp; W_Tnew==<span class="hljs-number">0</span>)? <span class="hljs-number">2&#x27;b01</span>:<br><span class="hljs-number">2&#x27;b00</span>;<br><br><span class="hljs-keyword">assign</span> newRegData = <br>(sel == <span class="hljs-number">2&#x27;b10</span>) ? M_RegWriteData:<br>(sel == <span class="hljs-number">2&#x27;b01</span>) ? W_RegWriteData:<br>RegData;<br></code></pre></td></tr></table></figure>

<h4 id="P5-小结"><a href="#P5-小结" class="headerlink" title="P5 小结"></a>P5 小结</h4><p>阻塞和转发可以说是流水线寄存器搭建中最困难、最难以理解的一部分。课上新增指令最大的难点也出在这里，如何正确、高效地进行数据的阻塞、转发，值得课下需要好好花一番功夫。</p>
<h3 id="对-CPU-进行扩展"><a href="#对-CPU-进行扩展" class="headerlink" title="对 CPU 进行扩展"></a>对 CPU 进行扩展</h3><h4 id="支持更多指令"><a href="#支持更多指令" class="headerlink" title="支持更多指令"></a>支持更多指令</h4><p>按照不同指令类别按类添加即可，“照葫芦画瓢”。</p>
<h4 id="存储器外置"><a href="#存储器外置" class="headerlink" title="存储器外置"></a>存储器外置</h4><p>在顶层新增对应接线即可。不过在输出 <code>m_data_wdata</code> 时需要注意将要输出的字节进行“对齐”。<br>例：我们想往 *00000001 处写入字节 0x56，按照教程要求，<code>m_data_byteen</code> 设置为 4’b0010。若我们直接将 <code>m_data_wdata</code> 设为 0x00000056，则向对应地址只会写入 0x00。原因就在官方给出的 testbench 中——</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span> (m_data_byteen[<span class="hljs-number">3</span>]) fixed_wdata[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>] = m_data_wdata[<span class="hljs-number">31</span>:<span class="hljs-number">24</span>];<br><span class="hljs-keyword">if</span> (m_data_byteen[<span class="hljs-number">2</span>]) fixed_wdata[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>] = m_data_wdata[<span class="hljs-number">23</span>:<span class="hljs-number">16</span>];<br><span class="hljs-keyword">if</span> (m_data_byteen[<span class="hljs-number">1</span>]) fixed_wdata[<span class="hljs-number">15</span>: <span class="hljs-number">8</span>] = m_data_wdata[<span class="hljs-number">15</span>: <span class="hljs-number">8</span>];<br><span class="hljs-keyword">if</span> (m_data_byteen[<span class="hljs-number">0</span>]) fixed_wdata[<span class="hljs-number">7</span> : <span class="hljs-number">0</span>] = m_data_wdata[<span class="hljs-number">7</span> : <span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>

<p>此时 <code>fixed_wdata</code> 被设定为 0x0000<strong>00</strong>00，这不是我们想要的结果，正确的结果应该是 0x0000<strong>56</strong>00。我们应当将 0x00000056 左移 8 位。对于写入其他的内存地址，操作以此类推。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> m_data_wdata =( M_rtVal &lt;&lt; &#123;&#123;m_data_addr[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]&#125;, &#123;<span class="hljs-number">3&#x27;b000</span>&#125;&#125;);<br></code></pre></td></tr></table></figure>

<h4 id="添加乘除模块"><a href="#添加乘除模块" class="headerlink" title="添加乘除模块"></a>添加乘除模块</h4><p>在真实的 CPU 中，乘除模块工作很慢，一般需要多个时钟周期才能完成计算，我们设计的 CPU 通过 <code>busy</code> 和 <code>start</code> 信号来模拟了这一特征。对于乘除计算指令，先输出一周期的 <code>start</code> 信号，然后输出若干周期的 <code>busy</code> 信号。</p>
<p>我采用了“有限状态机”来实现乘除模块。在我的设计中，MDU 模块的输入端口 A 和 B 与 ALU 的输入端口共用接线，而乘除指令后跟非乘除指令不会阻塞，若我们不将操作数用寄存器保存起来，则我们在<strong>最后一个 <code>busy</code> 为高电平的周期</strong>执行计算时运用的数据就不正确，所以我们在 <strong><code>start</code> 为高电平的周期</strong>保存了操作数，并置位了 <code>state</code>。具体请见以下代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> busy = (state!=<span class="hljs-number">0</span>);<br><span class="hljs-keyword">assign</span> start = (state==<span class="hljs-number">0</span>) &amp;&amp; (mult || multu || div || divu);<br><br><span class="hljs-keyword">if</span>(state==<span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(start) <span class="hljs-keyword">begin</span><br>        state=calcTime;<br>        MultOp_reg=MultOp;<br>        A_reg=A;<br>        B_reg=B;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(mthi) <span class="hljs-keyword">begin</span><br>        HI_reg = A;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mtlo) <span class="hljs-keyword">begin</span><br>        LO_reg = A;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state==<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>	<span class="hljs-comment">//最后一个周期执行计算</span><br>    state = state-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">case</span> (MultOp_reg)<br>        `mult_mult:<span class="hljs-keyword">begin</span><br>            &#123;HI_reg, LO_reg&#125; = <span class="hljs-built_in">$signed</span>(A_reg) * <span class="hljs-built_in">$signed</span>(B_reg);<br>        <span class="hljs-keyword">end</span><br>        `mult_multu:<span class="hljs-keyword">begin</span><br>            &#123;HI_reg, LO_reg&#125; = A_reg * B_reg;<br>        <span class="hljs-keyword">end</span><br>        `mult_div:<span class="hljs-keyword">begin</span><br>            HI_reg = <span class="hljs-built_in">$signed</span>(A_reg) % <span class="hljs-built_in">$signed</span>(B_reg);<br>            LO_reg = <span class="hljs-built_in">$signed</span>(A_reg) / <span class="hljs-built_in">$signed</span>(B_reg);<br>        <span class="hljs-keyword">end</span><br>        `mult_divu:<span class="hljs-keyword">begin</span><br>            HI_reg = A_reg % B_reg;<br>            LO_reg = A_reg / B_reg;<br>        <span class="hljs-keyword">end</span><br>        `mult_special:<span class="hljs-keyword">begin</span><br>            HI_reg = HI_reg;<br>            LO_reg = LO_reg;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    state=state-<span class="hljs-number">1</span>;	<span class="hljs-comment">//模拟运算周期数</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<img src="/images/p5_p6_mdu.png" width=100% height=100% align=center/>

<h3 id="P5-思考题"><a href="#P5-思考题" class="headerlink" title="P5 思考题"></a>P5 思考题</h3><h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p><strong>我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。</strong></p>
<p>如果“总是不跳转“，这一方法并不总能提高效率。我们的流水线也只有五级，提前判断分支在 D 级完成，总体来说是否提前对效率影响不太大。</p>
<h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p><strong>因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？</strong></p>
<p>延迟槽中的指令总会被执行，所以我们要记录下 2 条指令的地址，即 PC + 8。</p>
<h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><p><strong>我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU ），请思考为什么？</strong></p>
<p>从功能部件转发会导致关键路径变长，所需时间大于 CPU 时钟周期，可能出现毛刺。</p>
<h4 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h4><p><strong>我们为什么要使用 GPR 内部转发？该如何实现？</strong></p>
<p>① 此时 W 级的数据还没有写入 D 级，但 D 级需要读取这一数据。内部转发正是为了满足这个需求。</p>
<p>② 如果写入数据地址和读出数据地址相同，且写入信号有效，则读出写入的数据。</p>
<h4 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h4><p><strong>我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？</strong></p>
<p>数据来自 M 级和 W 级，分别对应 E_ALUOut 和 M_DMOut，后者有更高的优先级。D，E，M 级都可能需要这些数据。</p>
<h4 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h4><p><strong>在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</strong></p>
<p>我们可以将需要实现的指令分为以下几类：</p>
<ol>
<li>计算类：<code>add</code>，<code>sub</code>，<code>ori</code>，<code>lui</code> 等</li>
<li>存储类：<code>lw</code> 等</li>
<li>访存类：<code>sw</code> 等</li>
<li>分支类：<code>beq</code> 等</li>
<li>跳转并链接类：<code>jal</code> 等</li>
<li>跳回类：<code>jr</code> 等</li>
</ol>
<p>需要增改的位置如下表所示，“1”表示需要改变，“?”表示视情况而定。</p>
<table>
<thead>
<tr>
<th></th>
<th>计算</th>
<th>存储</th>
<th>访存</th>
<th>分支</th>
<th>跳转并链接</th>
<th>跳回</th>
</tr>
</thead>
<tbody><tr>
<td>D 级控制器</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>流水线寄存器</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>M 级 ALU</td>
<td>?</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>D 级比较器</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>写入数据</td>
<td></td>
<td></td>
<td>1</td>
<td>?</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<h4 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h4><p><strong>确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。</strong></p>
<p>采用集中式译码，不需要在每一级流水线再实例化 Controller，从而节省资源。但是我们需要将这些信号逐级流水，编写代码时需要小心。</p>
<h3 id="P6-思考题"><a href="#P6-思考题" class="headerlink" title="P6 思考题"></a>P6 思考题</h3><h4 id="第一题-1"><a href="#第一题-1" class="headerlink" title="第一题"></a>第一题</h4><p><strong>为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？</strong></p>
<p>乘除法部件的延迟远大于 ALU 的延迟，如果将乘除法整合到 ALU，时钟周期就必须要变长；独立的 HI，LO 寄存器有利于将乘除法运算和其他运算分离开来，乘除法指令在执行时其他不需要用到乘除模块的指令也不受影响，可以提高效率。</p>
<h4 id="第二题-1"><a href="#第二题-1" class="headerlink" title="第二题"></a>第二题</h4><p><strong>真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。</strong></p>
<p>早期的流水线 CPU：</p>
<p>通过多个时钟周期，执行移位-加（对于乘法）或移位-减（对于除法）的算法，一步步地计算出结果。我们在 P6 中需要实现的流水线 CPU 对乘除指令的处理与此有一定相似之处。</p>
<p>现代的流水线 CPU：</p>
<p>CPU内部不仅有简单的整数ALU，还有专门的乘法单元（IMUL），有时甚至还有专门的除法单元。配合CPU的<strong>乱序执行</strong>引擎，当遇到一条乘除指令时，调度器会将其发射到乘法单元。在乘法单元工作的这几个周期里，流水线<strong>不会被完全停顿</strong>，只要后续指令不依赖于这个乘法的结果，它们就可以继续被发射和执行。</p>
<p>此外，现代乘法器通常采用Booth编码和Wallace树结构来减少部分积的数量和加速累加，从而降低延迟和功耗。</p>
<h4 id="第三题-1"><a href="#第三题-1" class="headerlink" title="第三题"></a>第三题</h4><p><strong>请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</strong></p>
<p>对 F2DReg 和 D2EReg 进行阻塞，其中 D2EReg 中 E 级信号的输出应该“清空”，但 PC 信号需要保留。由于类似功能在 P5 时已经实现，P6 时将 <code>D_stall</code> 信号改为 <code>stall || E_mduStall</code> 条件即可。</p>
<h4 id="第四题-1"><a href="#第四题-1" class="headerlink" title="第四题"></a>第四题</h4><p><strong>请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</strong></p>
<p>能够很清晰地指示哪个字节会发生变动，将不同数据宽度的访存指令的实现方式进行了统一，有效减少了重复代码量。</p>
<h4 id="第五题-1"><a href="#第五题-1" class="headerlink" title="第五题"></a>第五题</h4><p><strong>请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</strong></p>
<p>获得和写入的数据都是 32 位的，不过我们只对选中的字节进行操作；将 DM 进行“分片”，分割成 4 个 8 位数据宽度的小 DM，这样我们每次就可以直接对某个字节进行操作，而不需要先读出整个字的数据再将特定字节替换。</p>
<h4 id="第六题-1"><a href="#第六题-1" class="headerlink" title="第六题"></a>第六题</h4><p><strong>为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</strong></p>
<p>规范性：对于每一个信号都标注其所处阶段，例如 <code>D_WriteReg</code>，且不吝啬变量名长度以提高可读性；使用宏定义替代“魔法值”，便于 debug。<br>抽象性：将需要添加的指令进行分类，同一类的指令对内存、寄存器等的操作均有很大相似之处，这在 CPU 设计部分已经提到。</p>
<h4 id="第七题-1"><a href="#第七题-1" class="headerlink" title="第七题"></a>第七题</h4><p><strong>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</strong></p>
<p>相比 P5 多出了 <code>mv_fr</code> 类指令带来的冲突。<code>start</code> 或 <code>busy</code> 信号为 1 且 D 级紧跟乘除指令时均需要对 F2DReg 和 D2EReg 进行阻塞，其中 D2EReg 中 E 级信号的输出应该“清空”，以防将错误数据代入 E 级且后续错误的计算结果又被流水。</p>
<h4 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h4><p><strong>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。</strong></p>
<p>样例构造采取大部分随机生成 + 少部分手搓的策略。</p>
<p>随机样例：只操作少数几个寄存器和少数内存地址，由于数据按照几百上千行的规模随机生成，所以能够以比较大的几率产生各种转发 &#x2F; 阻塞情景。</p>
<p>手搓样例：用于增加对转发 &#x2F; 阻塞情景的覆盖率，尤其是和分支、跳转等有关的，这在随机生成样例时很难控制合法性。</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><code class="hljs mips"><span class="hljs-meta">.data</span><br><span class="hljs-symbol">array:</span><span class="hljs-meta">.space</span> <span class="hljs-number">4096</span><br><br><span class="hljs-meta">.text</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">2</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">2000</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">3</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">3000</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">4</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">5000</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">5</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">4000</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">6</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">4000</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-number">5</span>,$<span class="hljs-number">6</span>,$<span class="hljs-number">5</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">7</span>,<span class="hljs-number">0</span>($<span class="hljs-number">5</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">5</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-number">3</span>,<span class="hljs-number">4</span>($<span class="hljs-number">0</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-number">4</span>,<span class="hljs-number">8</span>($<span class="hljs-number">0</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-number">2</span>,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-number">3</span>,<span class="hljs-number">16</span>($<span class="hljs-number">0</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-number">4</span>,<span class="hljs-number">20</span>($<span class="hljs-number">0</span>)<br><span class="hljs-keyword">add </span>$<span class="hljs-number">3</span>,$<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>	<span class="hljs-comment">#$3=5000</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">3</span>,$<span class="hljs-number">4</span>,label2<br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">label1:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">label2:</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">5</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">4</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">6</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">8</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span>,$<span class="hljs-number">6</span><br><span class="hljs-keyword">mult </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">6</span><br><span class="hljs-keyword">mflo </span>$<span class="hljs-number">9</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">8</span>,<span class="hljs-number">0</span>($<span class="hljs-number">9</span>)<br><span class="hljs-keyword">mfhi </span>$<span class="hljs-number">8</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">8</span>,<span class="hljs-number">0</span>($<span class="hljs-number">7</span>)<br><span class="hljs-keyword">ori </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span>,<span class="hljs-number">4</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">8</span>,<span class="hljs-number">0</span>($<span class="hljs-number">7</span>)<br><span class="hljs-keyword">ori </span>$<span class="hljs-number">9</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">12</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">8</span>,$<span class="hljs-number">0</span>,$<span class="hljs-number">9</span><br><span class="hljs-keyword">lb </span>$<span class="hljs-number">8</span>,-<span class="hljs-number">1</span>($<span class="hljs-number">9</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-number">7</span>,<span class="hljs-number">0</span>($<span class="hljs-number">8</span>)<br><span class="hljs-keyword">ori </span>$<span class="hljs-number">10</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">0x8765</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">10</span>,<span class="hljs-number">8</span>($<span class="hljs-number">0</span>)<br><span class="hljs-keyword">lh </span>$<span class="hljs-number">8</span>,-<span class="hljs-number">2</span>($<span class="hljs-number">9</span>)<br><span class="hljs-keyword">div </span>$<span class="hljs-number">8</span>,$<span class="hljs-number">9</span><br><span class="hljs-keyword">jal </span>label4<br><span class="hljs-keyword">mthi </span>$<span class="hljs-number">31</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">label3:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">label4:</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">8</span>,$<span class="hljs-number">31</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">jal </span>label6<br><span class="hljs-keyword">div </span>$<span class="hljs-number">4</span>,$<span class="hljs-number">31</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">label5:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">label6:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">31</span>,label7<br><span class="hljs-keyword">mfhi </span>$<span class="hljs-number">5</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">5</span>,$<span class="hljs-number">31</span>,label7<br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jal </span>label8<br><span class="hljs-keyword">addi </span>$<span class="hljs-number">5</span>,$<span class="hljs-number">31</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">label7:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">label8:</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-number">10</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-number">9</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">10</span>,$<span class="hljs-number">9</span>,label10<br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jal </span>label10<br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jal </span>end<br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">label9:</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">label10:</span><br><span class="hljs-keyword">jal </span>label11<br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">label11:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">0</span>,$<span class="hljs-number">0</span>,end<br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">31</span>,$<span class="hljs-number">0</span>,end<br><span class="hljs-keyword">nop</span><br></code></pre></td></tr></table></figure>

<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>P5、P6 的难度相比之前有了明显的提升。想要在这两个单元顺利一点，可以考虑课下自行构造较强的测试数据、练习指令添加推荐题。P5 和 P6 上机考试的“底层逻辑”都是相同的，一般是计算 + 分支 + 访存的组合，不过 P6 的考题在流程上会更为复杂（可以说结合了一定代码量的程序设计题），考场上需要更加细心，有更充分的耐心。</p>
<p>后续我有计划更新 P5、P6 考题中的常见“套路”，以帮助大家更顺利地通过课上部分，不要像我一样在 P6 连死 2 次。不过，即使发生了类似情况也不要放弃——笔者在 P3 死了 1 次，在 P6 死了 2 次，虽然用完了容错机会，但还是背水一战，完成了 P7。相信你们只会比我做得更好！</p>
<p>祝大家成功！</p>
]]></content>
      <categories>
        <category>计算机组成课下</category>
      </categories>
      <tags>
        <tag>计算机组成</tag>
        <tag>流水线 CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成 P3 / P4 课下——单周期 CPU</title>
    <url>/2025/11/23/p3p4_learn/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>通过阅读这篇帖子，你能够学习到如何搭建一个单周期的 CPU，并能对其中的一些重要问题加以认识。由于 P3 和 P4 课下任务相似度高，所以这里将两次课下作业的学习内容合并到同一篇帖子中来讲述。</p>
<span id="more"></span>

<h3 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h3><p>搭建支持 <code>add</code>，<code>sub</code>，<code>ori</code>，<code>lui</code>，<code>lw</code>，<code>sw</code>，<code>beq</code>，<code>jal</code>，<code>jr</code>，<code>nop</code> 指令的<strong>单周期</strong> CPU。</p>
<h3 id="明确设计"><a href="#明确设计" class="headerlink" title="明确设计"></a>明确设计</h3><p>先从 P3 的 Logisim CPU 开始，因为它比较直观，能够为 P4：用 Verilog 描述 CPU 提供较大的帮助。根据教程，我们的 CPU 大致由这几个模块构成：IFU、CTRL、GRF、EXT、ALU、DM。这些缩写对应的组件及其功能在教程中都有详细的说明，这里不再赘述。</p>
<h4 id="IFU"><a href="#IFU" class="headerlink" title="IFU"></a>IFU</h4><p>内部包含了 IM、PC、nPC 组件。IM 根据当前 PC 值取出对应的指令；PC 中有寄存器，在时钟上升沿时写入下一个 PC 值；nPC 则是一个状态转移单元，根据当前 PC 以及其他信号的输出判断下一个 PC 值。</p>
<ul>
<li>IM</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PC</td>
<td>input</td>
<td>32</td>
<td>当前 PC 值</td>
</tr>
<tr>
<td>Instr</td>
<td>output</td>
<td>32</td>
<td>取出的指令</td>
</tr>
</tbody></table>
<p>这里需要注意，在实际的 MIPS 架构中，PC 的起始地址是 0x00003000，对应存储单元的地址是 0；PC 每增加4，对应存储单元的地址增加 1。无论是在 Logisim 还是在 Verilog 中都需要注意这一映射关系。</p>
<ul>
<li>PC</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td>1</td>
<td>复位信号</td>
</tr>
<tr>
<td>nPC</td>
<td>input</td>
<td>32</td>
<td>下一个 PC 值</td>
</tr>
<tr>
<td>PC</td>
<td>output</td>
<td>32</td>
<td>当前 PC 值</td>
</tr>
</tbody></table>
<ul>
<li>nPC</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PC</td>
<td>input</td>
<td>32</td>
<td>当前 PC 值</td>
</tr>
<tr>
<td>offset</td>
<td>input</td>
<td>16</td>
<td>16 位立即数</td>
</tr>
<tr>
<td>instr_index</td>
<td>input</td>
<td>26</td>
<td>26 位立即数</td>
</tr>
<tr>
<td>PC_from_rs</td>
<td>input</td>
<td>32</td>
<td>rs 寄存器中存储的 PC（<code>jr</code> 使用）</td>
</tr>
<tr>
<td>branch</td>
<td>input</td>
<td>1</td>
<td>是否分支</td>
</tr>
<tr>
<td>jump</td>
<td>input</td>
<td>1</td>
<td>是否跳转</td>
</tr>
<tr>
<td>jump_back</td>
<td>input</td>
<td>1</td>
<td>是否跳回</td>
</tr>
<tr>
<td>nPC</td>
<td>output</td>
<td>32</td>
<td>下一个 PC 值</td>
</tr>
<tr>
<td>PCwith4</td>
<td>output</td>
<td>32</td>
<td>PC + 4（<code>jal</code> 使用）</td>
</tr>
</tbody></table>
<ul>
<li>IM</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PC</td>
<td>input</td>
<td>32</td>
<td>当前 PC 值</td>
</tr>
<tr>
<td>Instr</td>
<td>output</td>
<td>32</td>
<td>当前指令</td>
</tr>
</tbody></table>
<ul>
<li>Decode</li>
</ul>
<p>由于后续过程中我们需要用到 rs、rt、rd 等值，这里我们新增 Decode 模块，根据当前指令“翻译”出这些值。</p>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Instr</td>
<td>input</td>
<td>32</td>
<td>当前指令</td>
</tr>
<tr>
<td>op</td>
<td>output</td>
<td>6</td>
<td>[31:26]</td>
</tr>
<tr>
<td>func</td>
<td>output</td>
<td>6</td>
<td>[5:0]</td>
</tr>
<tr>
<td>rs</td>
<td>output</td>
<td>5</td>
<td>[25:21]</td>
</tr>
<tr>
<td>rt</td>
<td>output</td>
<td>5</td>
<td>[20:16]</td>
</tr>
<tr>
<td>rd</td>
<td>output</td>
<td>5</td>
<td>[15:11]</td>
</tr>
<tr>
<td>shamt</td>
<td>output</td>
<td>5</td>
<td>[10:6]（供 <code>nop</code> 和 <code>sll</code> 等使用）</td>
</tr>
<tr>
<td>immediate16</td>
<td>output</td>
<td>16</td>
<td>[15:0]</td>
</tr>
<tr>
<td>immediate26</td>
<td>output</td>
<td>26</td>
<td>[25:0]</td>
</tr>
</tbody></table>
<h4 id="CTRL"><a href="#CTRL" class="headerlink" title="CTRL"></a>CTRL</h4><p>CTRL 用于根据当前指令生成控制信号，这里我们采用和教程中相同的 AND-OR 方法，即现根据 op 和 func 判断当前指令，再生成对应控制信号。</p>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>op</td>
<td>input</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>func</td>
<td>input</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>RegDst</td>
<td>output</td>
<td>1</td>
<td>写入寄存器是否是 rd</td>
</tr>
<tr>
<td>RegWrite</td>
<td>output</td>
<td>1</td>
<td>是否写寄存器</td>
</tr>
<tr>
<td>MemRead</td>
<td>output</td>
<td>1</td>
<td>是否读内存</td>
</tr>
<tr>
<td>MemWrite</td>
<td>output</td>
<td>1</td>
<td>是否写内存</td>
</tr>
<tr>
<td>ExtOp</td>
<td>output</td>
<td>1</td>
<td>零扩展（0），符号扩展（1）</td>
</tr>
<tr>
<td>ALUSrc</td>
<td>output</td>
<td>1</td>
<td>第二个操作数源于 rt（0），源于扩展后立即数（1）</td>
</tr>
<tr>
<td>ALUOp</td>
<td>output</td>
<td>3</td>
<td>ALU 运算类型</td>
</tr>
<tr>
<td>MemToReg</td>
<td>output</td>
<td>1</td>
<td>是否将内存读出的内容写入寄存器</td>
</tr>
<tr>
<td>branch</td>
<td>output</td>
<td>1</td>
<td>是否分支</td>
</tr>
<tr>
<td>jump</td>
<td>output</td>
<td>1</td>
<td>是否跳转</td>
</tr>
<tr>
<td>jump_back</td>
<td>output</td>
<td>1</td>
<td>是否跳回</td>
</tr>
<tr>
<td>link</td>
<td>output</td>
<td>1</td>
<td>是否链接 PC + 4</td>
</tr>
</tbody></table>
<blockquote>
<p>注意这里的 <code>branch</code> 信号的含义其实是“是否是<strong>分支类型的指令</strong>”，NPC 中 <code>branch</code> 的实际含义是“是否<strong>执行分支</strong>”，执行分支的条件是：是分支类型的指令，且满足某个条件。</p>
<p>对于 <code>jump</code>、<code>jump_back</code> 等信号也是类似的，执行跳转、跳回可能也是需要条件的，这一点在课上部分会有所体现。</p>
</blockquote>
<h4 id="GRF"><a href="#GRF" class="headerlink" title="GRF"></a>GRF</h4><p>具有 32 个寄存器的寄存器堆，这一部分可以直接把 P0 课下的设计挪用过来。</p>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td>1</td>
<td>复位信号</td>
</tr>
<tr>
<td>A1</td>
<td>input</td>
<td>5</td>
<td>读寄存器地址 1</td>
</tr>
<tr>
<td>A2</td>
<td>input</td>
<td>5</td>
<td>读寄存器地址 2</td>
</tr>
<tr>
<td>A3</td>
<td>input</td>
<td>5</td>
<td>写寄存器地址</td>
</tr>
<tr>
<td>WD</td>
<td>input</td>
<td>32</td>
<td>写寄存器数据</td>
</tr>
<tr>
<td>write_enable</td>
<td>input</td>
<td>1</td>
<td>是否写寄存器</td>
</tr>
<tr>
<td>WD1</td>
<td>output</td>
<td>32</td>
<td>读寄存器数据 1</td>
</tr>
<tr>
<td>WD2</td>
<td>output</td>
<td>32</td>
<td>读寄存器数据 2</td>
</tr>
</tbody></table>
<h4 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h4><p>对 16 位立即数进行扩展，有零扩展、符号扩展两种选项。</p>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>immediate16</td>
<td>input</td>
<td>16</td>
<td>16 位立即数</td>
</tr>
<tr>
<td>ExtOp</td>
<td>input</td>
<td>1</td>
<td>零扩展（0），符号扩展（1）</td>
</tr>
<tr>
<td>extended</td>
<td>output</td>
<td>32</td>
<td>扩展结果</td>
</tr>
</tbody></table>
<h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h4><p>根据输入的操作数及 ALUOp 进行运算。</p>
<table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>input</td>
<td>32</td>
<td>操作数 1</td>
</tr>
<tr>
<td>B</td>
<td>input</td>
<td>32</td>
<td>操作数 2</td>
</tr>
<tr>
<td>S</td>
<td>input</td>
<td>5</td>
<td>shamt</td>
</tr>
<tr>
<td>ALUOp</td>
<td>input</td>
<td>3</td>
<td>运算类型</td>
</tr>
<tr>
<td>ALUOut</td>
<td>output</td>
<td>32</td>
<td>运算结果</td>
</tr>
<tr>
<td>Zero</td>
<td>output</td>
<td>1</td>
<td>运算结果是否为0（<code>beq</code> 使用）</td>
</tr>
</tbody></table>
<blockquote>
<p>ALUOp 值及对应的运算类型</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A + B</td>
</tr>
<tr>
<td>1</td>
<td>A - B</td>
</tr>
<tr>
<td>2</td>
<td>A | B</td>
</tr>
<tr>
<td>3</td>
<td>B &lt;&lt; 16</td>
</tr>
<tr>
<td>4</td>
<td>B &lt;&lt; S</td>
</tr>
<tr>
<td>5</td>
<td>预留</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h4><table>
<thead>
<tr>
<th>信号名</th>
<th>方向</th>
<th>位宽</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td>1</td>
<td>复位信号</td>
</tr>
<tr>
<td>address</td>
<td>input</td>
<td>32</td>
<td>操作地址</td>
</tr>
<tr>
<td>write_data</td>
<td>input</td>
<td>32</td>
<td>写入数据</td>
</tr>
<tr>
<td>write_enable</td>
<td>input</td>
<td>32</td>
<td>是否写内存</td>
</tr>
<tr>
<td>out_data</td>
<td>output</td>
<td>32</td>
<td>读出数据</td>
</tr>
</tbody></table>
<blockquote>
<p>Logisim 中，我们的 DM 利用 RAM 实现，RAM 的地址按照字编号，但是在实际的 MIPS 架构中，<code>.space</code> 的地址按照字节编号，这中间差了一个 4 倍。所以如果我们想要读出对应的字，需要将 <code>address</code> 右移 2 位得到 RAM 中对应字的地址。</p>
</blockquote>
<h3 id="电路及代码参考"><a href="#电路及代码参考" class="headerlink" title="电路及代码参考"></a>电路及代码参考</h3><p>对应的作业电路以及代码已经放到了我的 Github 仓库中，都能通过课上强测（但也不代表其设计完全合理）。建议大家批判性地参考仓库中内容。</p>
<p>顶层电路的连接如下图所示，这一工作也可以参考“黑书“和老师的 PPT 来完成。P4 和 P3 没有本质上的区别，完成 P4 比较容易的方式就是对照 P3 的设计图直接实例化各个模块，然后接线。</p>
<img src="/images/p3p4learn_mips.png" width=100% height=100% align=center/>

<h3 id="设计建议"><a href="#设计建议" class="headerlink" title="设计建议"></a>设计建议</h3><ol>
<li><p>我们在课下作业中已经实现了 <code>lw</code> 和 <code>sw</code>，那么也可以利用类似的思路实现对 <code>byte</code> 和 <code>half</code> 的读写，具体读写哪些位由 <code>address</code> 的低两位决定，具体内容参见 MIPS 指令集手册。</p>
</li>
<li><p>课上会要求新增一些奇怪的指令，可以试着做如下预留：</p>
<ul>
<li>在 CTRL 模块预留 <code>new</code> 输出（判断是否为新增指令）。</li>
<li>在 ALU 模块预留输出，用于输出其他的判断信号等</li>
<li>在 DM 模块预留输入接口，应对课上奇怪指令</li>
</ul>
<p>新增的指令在寄存器读写、内存读写上的逻辑会比较“独特”，下面我举出一例：</p>
<blockquote>
<p>对于新增指令 <code>new</code>，若满足一定条件才写寄存器</p>
</blockquote>
<p> 应对方法：改造 <code>RegWrite</code> 信号的生成逻辑，写寄存器的条件是：“是新指令且满足某个条件”或“是一定会写寄存器的指令”。注意输出的“写寄存器”的信号是<strong>经过或门的</strong>！</p>
 <img src="/images/p3p4learn_1.png" width=60% height=35% align=center/>
</li>
<li><p>课下的电路图不要画得太局促，以免课上新增数据通路时难以操作，这一点在 P3 中需要格外注意。P4 及以后都是用 Verilog 描述 CPU，应该不会存在这个问题。</p>
</li>
</ol>
<h3 id="P3-思考题"><a href="#P3-思考题" class="headerlink" title="P3 思考题"></a>P3 思考题</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h4><p><strong>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</strong></p>
<ul>
<li>状态存储：GRF 和 DM 部分。GRF 模块中保存了 32 个寄存器的当前值，这是我们判断自己的 CPU 能够正确工作的重要部分；DM 模块中存储了从指定寄存器加载的数据；GRF、DM 中存储的内容与输入一起，决定了如何向下一个状态转移。</li>
<li>状态转移：其他能够产生控制信号的部分。控制信号决定我们在这一时刻是否需要读写寄存器、是否需要读写数据存储单元、从哪些寄存器取出值、ALU 作什么运算…… 它们与当前状态存储部分一起，决定了下一个状态应该是什么。</li>
</ul>
<h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h4><p><strong>现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</strong></p>
<p>在这个阶段大体是合理的，由于我们不会对指令进行写操作，所以用 ROM 来存储指令足矣。不过，在实际的 MIPS 架构中，指令的起始地址为 0x00003000，而我们 ROM 的起始地址为 0x00000000，这稍显不符合；并且，我们将指令和数据段（data）分开在两个元件中存放，且二者的地址并不连续，这也和实际中的 MIPS 架构有所不同。</p>
<h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h4><p><strong>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</strong></p>
<p>具体描述见 Decoder 部分。</p>
<h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题 4"></a>问题 4</h4><p><strong>事实上，实现 <code>nop</code> 空指令，我们并不需要将它加入控制信号真值表，为什么？</strong></p>
<p><code>nop</code> 对应机器码的各个位均为 0，且本质是 <code>sll</code> 指令，这并不在本次课下作业的范围中。并且，若我们不将 <code>nop</code> 指令加入控制信号真值表：</p>
<ul>
<li>指定读入的寄存器 rt 为 0，而 <code>$0</code> 的值一直保持为 0，不会发生改变</li>
<li>信号 <code>MemWrite</code> 设置为 0，不会向 DM 中读入数据，DM 状态不改变</li>
</ul>
<p>因此，执行 <code>nop</code> 指令后，电路中状态不会有改变，这也就是执行“空指令”的体现。</p>
<h4 id="问题-5"><a href="#问题-5" class="headerlink" title="问题 5"></a>问题 5</h4><p><strong>阅读 Pre 的 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a> 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</strong></p>
<p>这些样例一定程度上能够完成检测工作，且可以发现 CPU 设计中较明显的问题。不过还有一些不足：</p>
<ul>
<li>对于 <code>add</code> 指令，对边界条件（例如 <code>int_max</code> 附近）的测试不够</li>
<li>对于 <code>lw</code> 和 <code>sw</code> 指令，没有在靠近最大地址的地方进行测试，且设置的 offset 均为 0，不能很好地检测对 base 和 offset 的运算。不过，由于本次实验没有实现 <code>li</code>，<code>addi</code> 等指令，offset 直接设为 0 无疑是最方便的。</li>
<li>对于  <code>lui</code> 和 <code>ori</code> 指令，可以适当多考虑一些更一般的值（无论正负）</li>
<li>对于 <code>beq</code> 指令，教程中的样例都是向后跳转，可以考虑添加向前 &#x2F; 原地跳转的情况</li>
</ul>
<h3 id="P4-思考题"><a href="#P4-思考题" class="headerlink" title="P4 思考题"></a>P4 思考题</h3><h4 id="问题-1-1"><a href="#问题-1-1" class="headerlink" title="问题 1"></a>问题 1</h4><p><strong>阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？</strong></p>
<ul>
<li>addr 信号来自于 ALU，ALU 要对 offset 和 base 作加法运算；</li>
<li>输入地址是以字为单位寻址的，要求为 4 的整数倍，对应到 DM 元件中需要除以 4 来寻址（即右移 2 位）。[1:0] 这两位可以用于半字、字节为单位的寻址，能预留用于添加 lh，lb 等指令。</li>
</ul>
<h4 id="问题-2-1"><a href="#问题-2-1" class="headerlink" title="问题 2"></a>问题 2</h4><p><strong>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。</strong></p>
<ul>
<li><p>将指令对应到信号：每个指令需要产生哪些控制信号一目了然，但是代码量较大；</p>
</li>
<li><p>将信号对应到指令：可以清楚地看到某个特定信号对应的指令，例如对于 <code>RegWrite</code>，我们可以很快就知道哪些指令需要写寄存器的操作。不过编程时要比较小心，因为不能直观地看到一个指令产生了什么控制信号，容易漏接线。</p>
</li>
<li><p>示例代码如下：</p>
<figure class="highlight smalltalk"><table><tr><td class="code"><pre><code class="hljs smalltalk">//信号到指令<br>assign <span class="hljs-type">RegDst</span> = <br>(add || sub || nop) ? `rd:<br>(ori || lw || lui) ? `rt:<br>(jal) ? `ra:<br>`rd;<br><br>assign <span class="hljs-type">ALUSrc</span> = (ori || lw || sw || lui);<br><br>assign <span class="hljs-type">RegDataSrc</span> =<br>(add || sub || ori || lui || nop) ? `alu:<br>(lw) ? `mem:<br>(jal) ? `pc:<br>`alu;<br>...<br><br>//指令到信号<br>if (add) begin<br>        <span class="hljs-type">MemWrite</span>    =   <span class="hljs-number">0</span>       ;<br>        <span class="hljs-type">RegWrite</span>    =   <span class="hljs-number">1</span>       ;<br>        <span class="hljs-type">Jr</span>          =   <span class="hljs-number">0</span>       ;<br>        <span class="hljs-type">Jump</span>        =   <span class="hljs-number">0</span>       ;<br>        <span class="hljs-type">Branch</span>      =   <span class="hljs-number">0</span>	;<br>        <span class="hljs-type">ExtOp</span>       =   <span class="hljs-number">0</span>	;<br>        <span class="hljs-type">ALUSrc</span>      =   <span class="hljs-number">0</span>	;<br>        <span class="hljs-type">ALUOp</span>       =   `<span class="hljs-type">ADD</span>	；<br>        <span class="hljs-type">RegDst</span>      =   `rd	；<br>end<br>...<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="问题-3-1"><a href="#问题-3-1" class="headerlink" title="问题 3"></a>问题 3</h4><p><strong>在相应的部件中，复位信号的设计都是同步复位 ，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。</strong></p>
<ul>
<li>同步复位：reset 信号低级于 clk 信号，因为只有 clk 处于上升沿时 reset 信号才可能有效；</li>
<li>异步复位：reset 信号高级于 clk 信号，因为一旦 reset 信号在高电平就复位，无所谓 clk 是否在上升沿。</li>
</ul>
<h4 id="问题-4-1"><a href="#问题-4-1" class="headerlink" title="问题 4"></a>问题 4</h4><p><strong>C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。</strong></p>
<ul>
<li>如何判断溢出：将  GPR[rs] 的第 31 位拼接到 GPR[rs] 之前，加法结果记为 temp，如果产生了进位就会溢出，这体现为 temp[32] ≠ temp[31]。</li>
<li>如果我们不考虑溢出，temp[32] 不会发生变化，也不会被存入到寄存器中，此时存入的结果仍然是两个 32 位数加法得到的结果，addi 与 addiu &#x2F; add 与 addu 是等价的。</li>
</ul>
<h3 id="上机提示"><a href="#上机提示" class="headerlink" title="上机提示"></a>上机提示</h3><p>上机一开始就可以将课下提交的电路提交到各题的窗口中进行评测，每道题都有大约一半的数据点是对课下内容的强测，不涉及任何新增指令。如果提交后发现每道题均有约一半的测试点可以通过，那么上机时就不要多去考虑课下的 bug 了。</p>
]]></content>
      <categories>
        <category>计算机组成课下</category>
      </categories>
      <tags>
        <tag>计算机组成</tag>
        <tag>单周期 CPU</tag>
      </tags>
  </entry>
</search>
